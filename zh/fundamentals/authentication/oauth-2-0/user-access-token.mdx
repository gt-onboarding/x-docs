---
title: 如何使用 OAuth 2.0（含 PKCE）的授权码流程连接到端点
sidebarTitle: OAuth 2.0 以用户身份发起请求
---

<div id="how-to-connect-to-endpoints-using-oauth-20-authorization-code-flow-with-pkce">
  ### 如何使用 OAuth 2.0（含 PKCE）的授权码流程连接到端点
</div>

<div id="how-to-connect-to-the-endpoints">
  #### 如何连接到这些端点
</div>

要对用户进行身份验证，你的应用需要实现授权流程。该流程允许你将用户引导至 X 的授权对话框。随后，X 的主站体验将显示授权对话框，并代表你的应用完成授权处理。用户可以选择授权你的应用或拒绝。用户作出选择后，X 会将其重定向回你的应用；此时你可以将授权码兑换为访问令牌（若用户已授权），或处理拒绝情况（若用户未授权）。

<div id="working-with-confidential-clients">
  #### 处理机密客户端
</div>

如果您正在处理机密客户端，在向令牌端点发起请求时，需使用[基本身份验证](https://datatracker.ietf.org/doc/html/rfc2617#section-2)方案，通过 base64 编码生成 Authorization 头。

在凭据中，`userid` 和 `password` 在一个 base64 编码的字符串内使用单个冒号（":"）分隔。

示例如下：

`-header 'Authorization: Basic V1ROclFTMTRiVWhwTWw4M2FVNWFkVGQyTldNNk1UcGphUTotUm9LeDN4NThKQThTbTlKSXQyZm1BanEzcTVHWC1icVozdmpKeFNlR3NkbUd0WEViUA=='`

如果用户代理需要发送 Client ID “Aladdin” 和密码 “open sesame”，应使用以下头字段：

`Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==`

要创建 Basic Authorization 头，您需要对 Client ID 和 Client Secret 进行 base64 编码。这些可在[开发者门户](https://developer.x.com/en/portal/dashboard)中您的 App 的“Keys and Tokens”页面获取。

<div id="steps-to-connect-using-oauth-20">
  #### 使用 OAuth 2.0 进行连接的步骤
</div>

**步骤 1：构建 Authorize URL**

你的应用需要构建一个指向 X 的 authorize URL，标明应用所需授权的 scope。例如，如果你的应用需要查询推文、用户并管理关注关系，应请求以下 scope：

`tweet.read%20users.read%20follows.read%20follows.write`

该 URL 还应包含 `code_challenge` 和 `state` 参数，以及其他必需参数。在生产环境中，`code_challenge` 应使用随机字符串。

**步骤 2：GET oauth2/authorize**

引导用户完成身份验证，并让其向你的应用返回授权码。如果你已为应用启用 OAuth 2.0，可在应用的“Keys and Tokens”页面找到你的 Client ID。

用于重定向用户的示例 URL 如下：

```
https://x.com/i/oauth2/authorize?response_type=code&client_id=M1M5R3BMVy13QmpScXkzTUt5OE46MTpjaQ&redirect_uri=https://www.example.com&scope=tweet.read%20users.read%20follows.read%20follows.write&state=state&code_challenge=challenge&code_challenge_method=plain
```

包含 offline\_access 的示例 URL 如下：

```
https://x.com/i/oauth2/authorize?response_type=code&client_id=M1M5R3BMVy13QmpScXkzTUt5OE46MTpjaQ&redirect_uri=https://www.example.com&scope=tweet.read%20users.read%20follows.read%20offline.access&state=state&code_challenge=challenge&code_challenge_method=plain
```

成功认证后，`redirect_uri` 会收到一个包含 `auth_code` 参数的请求。你的应用应验证 `state` 参数。

来自客户端重定向的示例请求如下：

```
https://www.example.com/?state=state&code=VGNibzFWSWREZm01bjN1N3dicWlNUG1oa2xRRVNNdmVHelJGY2hPWGxNd2dxOjE2MjIxNjA4MjU4MjU6MToxOmFjOjE
```

**步骤 3：POST oauth2/token - 访问令牌**

此时，你可以使用授权码创建访问令牌和刷新令牌（仅当请求了 `offline.access` scope 时）。可向以下端点发起 POST 请求：

```
https://api.x.com/2/oauth2/token
```

需要在请求头中传入 `Content-Type: application/x-www-form-urlencoded`。此外，请在请求体中包含：`code`、`grant_type`、`client_id`、`redirect_uri`，以及 `code_verifier`。

以下是面向公共客户端的令牌请求示例：

```json
curl --location --request POST 'https://api.x.com/2/oauth2/token' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--data-urlencode 'code=VGNibzFWSWREZm01bjN1N3dicWlNUG1oa2xRRVNNdmVHelJGY2hPWGxNd2dxOjE2MjIxNjA4MjU4MjU6MToxOmFjOjE' \
--data-urlencode 'grant_type=authorization_code' \
--data-urlencode 'client_id=rG9n6402A3dbUJKzXTNX4oWHJ' \
--data-urlencode 'redirect_uri=https://www.example.com' \
--data-urlencode 'code_verifier=challenge'
```

以下是使用机密客户端的示例： 

```json
curl --location --request POST 'https://api.x.com/2/oauth2/token' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--header 'Authorization: Basic V1ROclFTMTRiVWhwTWw4M2FVNWFkVGQyTldNNk1UcGphUTotUm9LeDN4NThKQThTbTlKSXQyZm1BanEzcTVHWC1icVozdmpKeFNlR3NkbUd0WEViUA=='\
--data-urlencode 'code=VGNibzFWSWREZm01bjN1N3dicWlNUG1oa2xRRVNNdmVHelJGY2hPWGxNd2dxOjE2MjIxNjA4MjU4MjU6MToxOmFjOjE' \
--data-urlencode 'grant_type=authorization_code' \
--data-urlencode 'redirect_uri=https://www.example.com' \
--data-urlencode 'code_verifier=challenge'
```

**步骤 4：连接到 API**

现在你已准备好使用 OAuth 2.0 连接到这些端点。为此，你将像使用[Bearer Token 认证](/zh/resources/fundamentals/authentication/oauth-2-0/application-only)那样发起 API 请求。但这一次不要传递 Bearer Token，而是使用你在上一步生成的访问令牌。作为响应，你应会看到与所请求端点相对应的负载。此请求对公共客户端和机密客户端均相同。

你将要发起的请求示例如下：

```json
curl --location --request GET 'https://api.x.com/2/tweets?ids=1261326399320715264,1278347468690915330' \
--header 'Authorization: Bearer Q0Mzb0VhZ0V5dmNXSTEyNER2MFNfVW50RzdXdTN6STFxQlVkTGhTc1lCdlBiOjE2MjIxNDc3NDM5MTQ6MToxOmF0OjE'
```

**步骤 5：POST oauth2/token - 刷新令牌**

刷新令牌允许应用在不提示用户的情况下获取新的访问令牌。你可以通过向以下端点发起 POST 请求来创建刷新令牌：https://api.x.com/2/oauth2/token。你需要在请求头中添加 `Content-Type: application/x-www-form-urlencoded`。此外，还需要传入 `refresh_token`，将 `grant_type` 设置为 `refresh_token`，并提供 `client_id`。

此请求适用于公共客户端：

```json
POST 'https://api.x.com/2/oauth2/token' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--data-urlencode 'refresh_token=bWRWa3gzdnk3WHRGU1o0bmRRcTJ5VUxWX1lZTDdJSUtmaWcxbTVxdEFXcW5tOjE2MjIxNDc3NDM5MTQ6MToxOnJ0OjE' \
--data-urlencode 'grant_type=refresh_token' \
--data-urlencode 'client_id=rG9n6402A3dbUJKzXTNX4oWHJ'
```

以下是一个适用于机密客户端的示例：

```json
POST 'https://api.x.com/2/oauth2/token' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--header 'Authorization: Basic V1ROclFTMTRiVWhwTWw4M2FVNWFkVGQyTldNNk1UcGphUTotUm9LeDN4NThKQThTbTlKSXQyZm1BanEzcTVHWC1icVozdmpKeFNlR3NkbUd0WEViUA=='\
--data-urlencode 'refresh_token=bWRWa3gzdnk3WHRGU1o0bmRRcTJ5VUxWX1lZTDdJSUtmaWcxbTVxdEFXcW5tOjE2MjIxNDc3NDM5MTQ6MToxOnJ0OjE'\
--data-urlencode 'grant_type=refresh_token'
```

**步骤 6：POST oauth2/revoke - 撤销令牌**

撤销令牌会使访问令牌或刷新令牌失效。它用于在客户端实现“退出登录”功能，便于清理与授权流程相关且可能已不再需要的安全凭证。撤销令牌供应用撤销令牌使用，而非供用户使用。若应用希望以编程方式撤销已获授的访问权限，你可以向以下 URL 发送 POST 请求以创建撤销令牌请求：

```
https://api.x.com/2/oauth2/revoke
```

你需要在请求头中传入 `Content-Type: application/x-www-form-urlencoded`，并提供令牌和 client\_id。

在某些情况下，用户可能希望撤销授予某个应用的访问权限，此时可访问[已连接的应用页面](https://x.com/settings/connected_apps)进行撤销。

```bash
curl --location --request POST 'https://api.x.com/2/oauth2/revoke' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--data-urlencode 'token=Q0Mzb0VhZ0V5dmNXSTEyNER2MFNfVW50RzdXdTN6STFxQlVkTGhTc1lCdlBiOjE2MjIxNDc3NDM5MTQ6MToxOmF0OjE' \
--data-urlencode 'client_id=rG9n6402A3dbUJKzXTNX4oWHJ'
```

以下请求适用于“机密客户端”（confidential clients）：

```bash
curl --location --request POST 'https://api.x.com/2/oauth2/revoke' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--header 'Authorization: Basic V1ROclFTMTRiVWhwTWw4M2FVNWFkVGQyTldNNk1UcGphUTotUm9LeDN4NThKQThTbTlKSXQyZm1BanEzcTVHWC1icVozdmpKeFNlR3NkbUd0WEViUA=='\
--data-urlencode 'token=Q0Mzb0VhZ0V5dmNXSTEyNER2MFNfVW50RzdXdTN6STFxQlVkTGhTc1lCdlBiOjE2MjIxNDc3NDM5MTQ6MToxOmF0OjE'
```