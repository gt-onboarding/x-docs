---
title: OAuth 2.0 권한 부여 코드 플로우(PKCE)로 엔드포인트에 연결하는 방법
sidebarTitle: OAuth 2.0 사용자 대리 요청
---

<div id="how-to-connect-to-endpoints-using-oauth-20-authorization-code-flow-with-pkce">
  ### OAuth 2.0 with PKCE 인증 코드 플로우를 사용해 엔드포인트에 연결하는 방법
</div>

<div id="how-to-connect-to-the-endpoints">
  #### 엔드포인트에 연결하는 방법
</div>

사용자를 인증하려면 앱에서 권한 부여 흐름을 구현해야 합니다. 이 흐름을 통해 사용자를 X의 권한 부여 대화상자로 안내할 수 있습니다. 그러면 기본 X 환경에서 권한 부여 대화상자를 표시하고 앱을 대신해 권한 부여를 처리합니다. 사용자는 앱에 권한을 부여하거나 거부할 수 있습니다. 사용자가 선택을 완료하면 X가 사용자를 앱으로 리디렉션하며, 그곳에서 권한 부여 코드를 액세스 토큰으로 교환(사용자가 앱을 승인한 경우)하거나 거부를 처리(사용자가 앱을 승인하지 않은 경우)할 수 있습니다.

<div id="working-with-confidential-clients">
  #### 기밀 클라이언트 사용하기
</div>

기밀 클라이언트와 작업하는 경우 토큰 엔드포인트에 요청할 때, base64 인코딩으로 인증 헤더를 생성하기 위해 [기본 인증](https://datatracker.ietf.org/doc/html/rfc2617#section-2) 스킴을 사용해야 합니다.

자격 증명에서 `userid`와 `password`는 base64로 인코딩된 문자열 내에서 콜론(":") 한 개로 구분됩니다.

예시는 다음과 같습니다:

`-header 'Authorization: Basic V1ROclFTMTRiVWhwTWw4M2FVNWFkVGQyTldNNk1UcGphUTotUm9LeDN4NThKQThTbTlKSXQyZm1BanEzcTVHWC1icVozdmpKeFNlR3NkbUd0WEViUA=='`

사용자 에이전트가 Client ID "Aladdin"과 비밀번호 "open sesame"를 보내려면 다음 헤더 필드를 사용합니다:

`Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==`

기본 인증 헤더를 생성하려면 앱의 “Keys and Tokens” 페이지( [developer portal](https://developer.x.com/en/portal/dashboard) 내)에서 확인할 수 있는 Client ID와 Client Secret에 대해 base64 인코딩을 수행해야 합니다.

<div id="steps-to-connect-using-oauth-20">
  #### OAuth 2.0를 사용하여 연결하는 단계
</div>

**1단계: Authorize URL 구성**

앱이 필요로 하는 권한 범위(scope)를 지정하여 X용 authorize URL을 구성해야 합니다. 예를 들어, 앱이 트윗 조회, 사용자 조회 및 팔로우 관리를 해야 한다면 다음과 같은 scope를 요청해야 합니다:

`tweet.read%20users.read%20follows.read%20follows.write`

이 URL에는 다른 필수 매개변수와 함께 `code_challenge`와 `state` 매개변수도 포함됩니다. 프로덕션 환경에서는 `code_challenge`에 임의의 문자열을 사용해야 합니다.

**2단계: GET oauth2/authorize**

사용자가 인증을 완료하면 애플리케이션으로 authorization code가 전달되도록 합니다. 앱에 대해 OAuth 2.0을 활성화했다면 앱의 “Keys and Tokens” 페이지에서 Client ID를 확인할 수 있습니다.

사용자를 리디렉션할 예시 URL은 다음과 같습니다:

```
https://x.com/i/oauth2/authorize?response_type=code&client_id=M1M5R3BMVy13QmpScXkzTUt5OE46MTpjaQ&redirect_uri=https://www.example.com&scope=tweet.read%20users.read%20follows.read%20follows.write&state=state&code_challenge=challenge&code_challenge_method=plain
```

offline\_access를 포함한 예시 URL은 다음과 같습니다:

```
https://x.com/i/oauth2/authorize?response_type=code&client_id=M1M5R3BMVy13QmpScXkzTUt5OE46MTpjaQ&redirect_uri=https://www.example.com&scope=tweet.read%20users.read%20follows.read%20offline.access&state=state&code_challenge=challenge&code_challenge_method=plain
```

인증이 성공하면 redirect\_uri로 auth\_code 매개변수를 포함한 요청이 전달됩니다. 애플리케이션은 state 매개변수를 검증해야 합니다.

클라이언트의 리디렉션으로부터 오는 요청 예시는 다음과 같습니다:

```
https://www.example.com/?state=state&code=VGNibzFWSWREZm01bjN1N3dicWlNUG1oa2xRRVNNdmVHelJGY2hPWGxNd2dxOjE2MjIxNjA4MjU4MjU6MToxOmFjOjE
```

**3단계: POST oauth2/token - Access Token**

이 시점에서 authorization code를 사용해 액세스 토큰과 리프레시 토큰(`offline.access` scope를 요청한 경우에만)을 발급받을 수 있습니다. 다음 엔드포인트로 POST 요청을 보냅니다:

```
https://api.x.com/2/oauth2/token
```

헤더에 `Content-Type`으로 `application/x-www-form-urlencoded`를 지정해야 합니다. 또한 요청 본문에는 `code`, `grant_type`, `client_id`, `redirect_uri`, `code_verifier`를 포함해야 합니다.

다음은 public client에 대한 토큰 요청 예시입니다:

```json
curl --location --request POST 'https://api.x.com/2/oauth2/token' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--data-urlencode 'code=VGNibzFWSWREZm01bjN1N3dicWlNUG1oa2xRRVNNdmVHelJGY2hPWGxNd2dxOjE2MjIxNjA4MjU4MjU6MToxOmFjOjE' \
--data-urlencode 'grant_type=authorization_code' \
--data-urlencode 'client_id=rG9n6402A3dbUJKzXTNX4oWHJ' \
--data-urlencode 'redirect_uri=https://www.example.com' \
--data-urlencode 'code_verifier=challenge'
```

다음은 confidential client를 사용하는 예시입니다: 

```json
curl --location --request POST 'https://api.x.com/2/oauth2/token' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--header 'Authorization: Basic V1ROclFTMTRiVWhwTWw4M2FVNWFkVGQyTldNNk1UcGphUTotUm9LeDN4NThKQThTbTlKSXQyZm1BanEzcTVHWC1icVozdmpKeFNlR3NkbUd0WEViUA=='\
--data-urlencode 'code=VGNibzFWSWREZm01bjN1N3dicWlNUG1oa2xRRVNNdmVHelJGY2hPWGxNd2dxOjE2MjIxNjA4MjU4MjU6MToxOmFjOjE' \
--data-urlencode 'grant_type=authorization_code' \
--data-urlencode 'redirect_uri=https://www.example.com' \
--data-urlencode 'code_verifier=challenge'
```

**4단계: API에 연결**

이제 OAuth 2.0을 사용해 엔드포인트에 연결할 준비가 되었습니다. 이를 위해 [Bearer Token 인증](/ko/resources/fundamentals/authentication/oauth-2-0/application-only)을 사용할 때와 동일한 방식으로 API를 호출합니다. Bearer Token을 전달하는 대신 직전 단계에서 생성한 액세스 토큰을 사용하세요. 응답으로는 요청한 엔드포인트에 해당하는 적절한 페이로드가 반환됩니다. 이 요청은 퍼블릭 클라이언트와 컨피덴셜 클라이언트 모두에 동일하게 적용됩니다.

요청 예시는 다음과 같습니다:

```json
curl --location --request GET 'https://api.x.com/2/tweets?ids=1261326399320715264,1278347468690915330' \
--header 'Authorization: Bearer Q0Mzb0VhZ0V5dmNXSTEyNER2MFNfVW50RzdXdTN6STFxQlVkTGhTc1lCdlBiOjE2MjIxNDc3NDM5MTQ6MToxOmF0OjE'
```

**5단계: POST oauth2/token - 리프레시 토큰**

리프레시 토큰은 사용자를 다시 확인 요청하지 않고도 애플리케이션이 새 액세스 토큰을 받을 수 있게 합니다. 다음 엔드포인트에 POST 요청을 보내 리프레시 토큰을 생성할 수 있습니다: https://api.x.com/2/oauth2/token 헤더에 `Content-Type`을 `application/x-www-form-urlencoded`로 추가해야 합니다. 또한 `refresh_token`을 전달하고, `grant_type`을 `refresh_token`으로 설정하며, `client_id`를 지정해야 합니다.

이 요청은 퍼블릭 클라이언트에서 동작합니다:

```json
POST 'https://api.x.com/2/oauth2/token' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--data-urlencode 'refresh_token=bWRWa3gzdnk3WHRGU1o0bmRRcTJ5VUxWX1lZTDdJSUtmaWcxbTVxdEFXcW5tOjE2MjIxNDc3NDM5MTQ6MToxOnJ0OjE' \
--data-urlencode 'grant_type=refresh_token' \
--data-urlencode 'client_id=rG9n6402A3dbUJKzXTNX4oWHJ'
```

컨피덴셜 클라이언트의 예시는 다음과 같습니다:

```json
POST 'https://api.x.com/2/oauth2/token' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--header 'Authorization: Basic V1ROclFTMTRiVWhwTWw4M2FVNWFkVGQyTldNNk1UcGphUTotUm9LeDN4NThKQThTbTlKSXQyZm1BanEzcTVHWC1icVozdmpKeFNlR3NkbUd0WEViUA=='\
--data-urlencode 'refresh_token=bWRWa3gzdnk3WHRGU1o0bmRRcTJ5VUxWX1lZTDdJSUtmaWcxbTVxdEFXcW5tOjE2MjIxNDc3NDM5MTQ6MToxOnJ0OjE'\
--data-urlencode 'grant_type=refresh_token'
```

**6단계: POST oauth2/revoke - 토큰 취소**

토큰 폐기는 액세스 토큰 또는 리프레시 토큰을 무효화합니다. 이는 클라이언트에서 “로그아웃” 기능을 구현할 때 사용되며, 더 이상 필요하지 않을 수 있는 권한 부여 플로우와 연관된 보안 자격 증명을 정리할 수 있게 합니다. 폐기 토큰은 사용자가 아니라 App이 토큰을 폐기할 때 사용됩니다. App이 자신에게 부여된 액세스를 프로그래매틱하게 폐기하려면 다음 URL로 POST 요청을 보내 폐기 토큰 요청을 생성할 수 있습니다:

```
https://api.x.com/2/oauth2/revoke
```

헤더에 `Content-Type`으로 `application/x-www-form-urlencoded`를 지정하고, 토큰과 client\_id를 함께 전달해야 합니다.

일부 경우 사용자가 App에 부여한 액세스를 해지하고자 할 수 있으며, 이때는 [연결된 앱 페이지](https://x.com/settings/connected_apps)를 방문해 직접 해지할 수 있습니다.

```bash
curl --location --request POST 'https://api.x.com/2/oauth2/revoke' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--data-urlencode 'token=Q0Mzb0VhZ0V5dmNXSTEyNER2MFNfVW50RzdXdTN6STFxQlVkTGhTc1lCdlBiOjE2MjIxNDc3NDM5MTQ6MToxOmF0OjE' \
--data-urlencode 'client_id=rG9n6402A3dbUJKzXTNX4oWHJ'
```

이 요청은 기밀 클라이언트에서도 동작합니다:

```bash
curl --location --request POST 'https://api.x.com/2/oauth2/revoke' \
--header 'Content-Type: application/x-www-form-urlencoded' \
--header 'Authorization: Basic V1ROclFTMTRiVWhwTWw4M2FVNWFkVGQyTldNNk1UcGphUTotUm9LeDN4NThKQThTbTlKSXQyZm1BanEzcTVHWC1icVozdmpKeFNlR3NkbUd0WEViUA=='\
--data-urlencode 'token=Q0Mzb0VhZ0V5dmNXSTEyNER2MFNfVW50RzdXdTN6STFxQlVkTGhTc1lCdlBiOjE2MjIxNDc3NDM5MTQ6MToxOmF0OjE'
```