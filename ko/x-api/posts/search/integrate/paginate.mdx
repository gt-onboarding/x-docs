---
title: 페이지 매김
sidebarTitle: 페이지 매김
---

\---MDX\_CONTENTEND---

<div id="recent-search-pagination">
  ### 최근 검색 페이지네이션
</div>

<div id="introduction">
  #### 소개
</div>

검색 쿼리는 보통 단일 API 응답으로 반환할 수 있는 것보다 더 많은 게시물과 일치합니다. 이 경우 데이터는 일련의 ‘페이지’로 반환됩니다. 페이지네이션이란 전체 데이터 세트를 가져오기 위해 모든 페이지를 순차적으로 요청하는 방법을 말합니다.

다음은 최근 검색 페이지네이션의 핵심 사항입니다:

- 최근 검색 엔드포인트는 쿼리에 최소 한 페이지로 응답하며, 추가 페이지가 있으면 JSON 응답에 next\_token을 제공합니다. 일치하는 게시물을 계속 받으려면 응답에 토큰이 더 이상 포함되지 않을 때까지 이 과정을 반복하면 됩니다.

- next\_token은 만료되지 않습니다. 동일한 next\_token 값을 사용하는 여러 요청은 요청 시점과 무관하게 동일한 결과를 받습니다.

- 게시물은 UTC 시간대 기준으로 최신순(역순)으로 제공됩니다. 이는 개별 페이지 내에서도, 여러 페이지 전체에서도 동일합니다:
  - 첫 번째 응답의 첫 번째 게시물은 쿼리와 일치하는 가장 최근 게시물입니다.
  - 마지막 응답의 마지막 게시물은 쿼리와 일치하는 가장 오래된 게시물입니다.

- max\_results 요청 매개변수를 통해 응답마다 반환되는 게시물 수를 설정할 수 있습니다. 기본값은 게시물 10개이며 최대 100개입니다.

- 모든 페이지네이션 구현에는 응답 페이로드에서 next\_token을 파싱하여 ‘다음 페이지’ 검색 요청에 포함하는 단계가 필요합니다. 이러한 ‘다음 페이지’ 요청을 구성하는 방법은 아래를 참조하세요.
   

최근 검색 엔드포인트는 두 가지 기본 사용 패턴을 지원하도록 설계되었습니다:

- **과거 데이터 가져오기** - 관심 기간의 일치하는 게시물을 요청합니다. 이는 일반적으로 과거 연구를 위한 일회성 요청입니다. 검색 요청은 start\_time 및 end\_time 요청 매개변수에 기반할 수 있습니다. 최근 검색 엔드포인트는 쿼리와 일치하는 가장 최근 게시물부터 역순으로 게시물을 반환합니다.

- **폴링** - 마지막으로 수신한 게시물 이후에 게시된 일치하는 게시물을 요청합니다. 이러한 사용 사례는 근실시간 성격을 띠며, 관심 있는 새 게시물을 “수신 대기”하기 위해 빈번한 요청이 특징입니다. 최근 검색 엔드포인트는 ‘폴링’ 패턴을 지원하기 위해 since\_id 요청 매개변수를 제공합니다. 게시물 ID로 탐색을 돕기 위해 until\_id 요청 매개변수도 사용할 수 있습니다.
   

다음으로 과거 모드에 대해 설명합니다. 이는 최근 검색 엔드포인트의 기본 모드이며 페이지네이션의 기본 개념을 보여줍니다. 이후 폴링 사용 사례의 예를 설명합니다. 폴링으로 인해 페이지네이션이 발생하는 경우, 검색 요청을 관리하기 위한 추가 단계가 필요합니다.
 

<div id="retrieving-historical-data">
  #### 과거 데이터 가져오기
</div>

이 섹션에서는 관심 있는 기간(현재는 최근 7일로 제한) 동안의 게시물을 start\_time 및 end\_time 요청 매개변수를 사용해 가져오는 방법을 설명합니다. 과거 데이터 요청은 일반적으로 연구 및 분석을 위한 일회성 요청입니다.

기간을 지정해 데이터를 요청하는 것은 recent search 엔드포인트의 기본 동작입니다. 검색 요청에서 start\_time, end\_time 또는 since\_id 요청 매개변수를 지정하지 않으면 end\_time은 기본적으로 “지금”(실제로는 쿼리 시점 기준 30초 전)으로, start\_time은 기본적으로 7일 전으로 설정됩니다.

엔드포인트는 가장 최근 게시물부터 시작해 최신순(내림차순)으로 첫 번째 ‘페이지’를 반환합니다. 응답 JSON 페이로드에는 추가 페이지가 있는 경우 next\_token도 포함됩니다. 페이지 수와 관계없이 일치하는 게시물 전체를 수집하려면 next\_token이 더 이상 제공되지 않을 때까지 요청을 반복합니다.

예를 들어, 지난주 동안 키워드 snow가 포함된 게시물을 조회하는 초기 요청은 다음과 같습니다:

https://api.x.com/2/tweets/search/recent?query=snow

응답에는 가장 최근 10개의 게시물과 함께 JSON 응답의 다음 “meta” 속성이 포함됩니다:

```
"meta": {
        "newest_id": "1204860593741553664",
        "oldest_id": "1204860580630278147",
        "next_token": "b26v89c19zqg8o3fobd8v73egzbdt3qao235oql",
        "result_count": 10
    }
```

다음 10개의 게시물을 가져오려면 이 next\_token을 원래 요청에 추가합니다. 요청은 다음과 같습니다:

https://api.x.com/2/tweets/search/recent?query=snow\&next\_token=b26v89c19zqg8o3fobd8v73egzbdt3qao235oql

next\_token을 확인해 후속 요청에 포함하는 과정을 모든(또는 원하는 수의) 게시물을 수집할 때까지, 또는 지정한 요청 횟수에 도달할 때까지 반복할 수 있습니다. 데이터 완전성(쿼리와 일치하는 모든 결과 수집)이 핵심인 경우, 단순히 “request.next\_token이 null이 될 때까지 반복”하는 설계로 충분합니다. 
 

<div id="polling-and-listening-use-cases">
  #### 폴링 및 리스닝 사용 사례
</div>

이 섹션에서는 `since_id` 요청 매개변수를 사용해 recent search 엔드포인트를 폴링하여 최근 게시물을 가져오는 방법을 설명합니다.

폴링 사용 사례에서는 “관심 있는 새 게시물이 있나요?”라는 쿼리를 지속적이고 빈번하게 수행합니다. 시간 기반의 과거 조회 사용 사례와 달리, 폴링 사용 사례는 일반적으로 게시물 ID를 기준으로 요청합니다.

폴링 패턴의 핵심은 모든 새 게시물에 X 플랫폼에서 일반적으로 오름차순으로 ‘발급’되는 [고유 ID](/ko/resources/fundamentals/x-ids)가 있다는 점입니다. 어느 게시물의 ID가 다른 것보다 작다면 더 먼저 게시되었다는 뜻입니다.

recent search 엔드포인트는 게시물 ID로 게시물 아카이브를 탐색하는 기능을 지원합니다. 엔드포인트의 응답에는 `oldest_id`와 `newest_id`가 포함됩니다. 폴링 모드에서는 지금까지 받은 가장 큰/가장 최신 ID를 `since_id`로 설정해 요청합니다.

예를 들어, 눈(snow)에 대한 새 게시물을 5분마다 조회하고, 마지막으로 받은 게시물의 ID가 10000이었다고 가정해 봅시다. 폴링 시점의 요청은 다음과 같습니다:

https://api.x.com/2/tweets/search/recent?query=snow\&since\_id=10000

다음으로, 지난 요청 이후 게시물 7개가 게시되었다고 해봅시다. 이들이 모두 단일 데이터 ‘페이지’에 들어가므로 `next_token`은 없습니다. 응답에는 가장 최근(최신) 게시물의 ID가 제공됩니다:

```
"meta": {
        "newest_id": "12000",
        "oldest_id": "10005",
        "result_count": 7
    }
```

다음 폴링 쿼리를 수행하려면 이 `newest_id` 값을 사용해 다음 `since_id` 매개변수를 설정합니다:

`https://api.x.com/2/tweets/search/recent?query=snow&since_id=12000`

더 많은 데이터가 있고 `next_token`이 제공되는 경우, 첫 번째 결과 페이지의 `newest_id` 값만 필요합니다. 각 데이터 페이지에는 `newest_id`와 `oldest_id`가 포함되지만, 다음 정기 폴링 요청에 필요한 값은 첫 번째 페이지의 값뿐입니다. 따라서 폴링 설계를 구현하거나 ID 범위로 게시물을 검색하는 경우 페이지네이션 로직이 조금 더 복잡합니다.

이제 추가로 일치하는 게시물이 18개 있다고 가정해 봅시다. 엔드포인트는 이 5분 구간에 대해 전체 데이터 페이지와 다음 페이지를 요청하기 위한 `next_token`이 포함된 초기 응답을 반환합니다. 또한 5분 후 다음 폴링 간격에 필요한 최신 게시물 ID도 포함합니다.

```
"meta": {
        "newest_id": "13800",
        "oldest_id": "12500",
        "next_token": "fnsih9chihsnkjbvkjbsc",
        "result_count": 10
    }
```

이 5분 구간의 모든 일치 데이터를 수집하려면, 다음 요청에서 이전 요청과 동일한 `since_id` 값과 함께 `next_token`을 전달하세요.

https://api.x.com/2/tweets/search/recent?query=snow\&since\_id=12000\&next\_token=fnsih9chihsnkjbvkjbsc

```
"meta": {
        "newest_id": "12300",
        "oldest_id": "12010",
        "result_count": 8
    }
```

이 두 번째 응답은 나머지 8개의 게시물을 제공하며 `next_token`은 없습니다. `newest_id` 값(12300)은 업데이트하지 않고, 첫 번째 응답의 `newest_id` 값을 기준으로 다음 `since_id` 요청을 구성한다는 점에 유의하세요:

https://api.x.com/2/tweets/search/recent?query=snow\&since\_id=13800