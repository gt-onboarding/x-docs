---
title: "Search API: Enterprise"
sidebarTitle: Search API
---

> **주의사항:**
>
> [X API v2](/ko/x-api/getting-started/about-x-api)에서 [게시물 검색](/ko/x-api/posts/search/introduction)과 [게시물 수](/ko/x-api/posts/counts/introduction)의 새 버전을 출시했습니다. X API v2의 [신규 사항을 확인](/ko/x-api/migrate/overview)하시기 바랍니다.
>
> 이 엔드포인트는 게시물 편집 메타데이터를 포함하도록 업데이트되었습니다. 이러한 메타데이터에 대해서는 ["게시물 편집" 기본 사항 페이지](/ko/x-api/enterprise-gnip-2.0/fundamentals/edit-tweets)에서 자세히 알아보세요. 

<div id="overview">
  ## 개요
</div>

`Enterprise`

_Enterprise API는 관리형 액세스 레벨에서만 사용할 수 있습니다. 이 API를 사용하려면 먼저 엔터프라이즈 영업팀을 통해 계정을 설정해야 합니다. 자세한 내용은 [여기](https://developer.x.com/en/products/x-api/enterprise)를 참조하세요._

_X API 검색 Post 제공 항목 전체는 [여기](/ko/x-api/enterprise-gnip-2.0/fundamentals/search-api)에서 확인할 수 있습니다._

Enterprise 검색 API는 두 가지가 있습니다:

1. 30-Day Search API는 직전 30일의 데이터를 제공합니다.
2. Full-Archive Search API는 2006년 3월의 첫 번째 Post까지 거슬러 올라가는 X 데이터 전체 코퍼스에 완전하고 즉시 액세스할 수 있게 해줍니다.

이 RESTful API는 요청당 최대 2,048자의 단일 쿼리를 지원합니다. 쿼리는 PowerTrack 규칙 구문으로 작성합니다. 자세한 내용은 [규칙 및 필터링](/ko/x-api/enterprise-gnip-2.0/fundamentals/rules-filtering#getting-started-with-enterprise-rules-and-queries)을 참조하세요. 사용자는 분 단위의 세분화 수준으로 임의의 기간을 지정할 수 있습니다. 다만, 응답은 지정한 maxResults 또는 31일 중 더 작은 한도로 제한되며, 다음 결과 묶음을 페이지네이션하기 위한 next 토큰이 포함됩니다. 시간 매개변수를 지정하지 않으면 API는 가장 최근 30일의 일치하는 데이터를 반환합니다.

Enterprise 검색 API는 분 단위 세분화로 Post 아카이브에 대해 지연이 낮고 충실도가 높은 쿼리 기반 액세스를 제공합니다. Post 데이터는 쿼리와 일치하는 가장 최근 Post부터 시작하여 최신순(역순 시간)으로 제공됩니다. 게시 후 약 30초가 지나면 검색 API에서 Post를 확인할 수 있습니다.

이 검색 엔드포인트는 편집된 Post 메타데이터를 제공합니다. 2022년 9월 29일 이후에 생성된 Post의 모든 객체에는 해당 Post가 한 번도 편집되지 않았더라도 Post 편집 메타데이터가 포함됩니다. Post가 편집될 때마다 새로운 Post ID가 생성됩니다. Post의 편집 기록은 원본 ID부터 시작하는 Post ID 배열로 기록됩니다.

이 엔드포인트는 항상 가장 최근 편집본과 편집 기록을 함께 반환합니다. 30분 편집 가능 시간 이후에 수집된 Post는 최종 버전을 나타냅니다. Edit Post 메타데이터에 대해 자세히 알아보려면 [Edit Posts 기본 사항](/ko/x-api/fundamentals/edit-posts) 페이지를 확인하세요.

요청에는 API 응답당 반환할 Post의 최대 수를 지정하는 maxResults 매개변수가 포함됩니다. 쿼리와 연관된 Post 수가 응답당 최대 결과 수를 초과하는 경우, 응답에 next 토큰이 포함됩니다. 이러한 next 토큰은 후속 요청에서 쿼리와 연관된 전체 Post 집합을 페이지네이션하는 데 사용됩니다.

이 Enterprise 검색 API는 쿼리와 연관된 데이터 볼륨을 요청할 수 있는 _counts_ 엔드포인트를 제공합니다. 

<div id="request-types">
  ### 요청 유형
</div>

엔터프라이즈 검색 API는 두 가지 종류의 요청을 지원합니다.

<div id="search-requests-data">
  #### 검색 요청(데이터)
</div>

엔터프라이즈 검색 API에 대한 검색 요청을 사용하면 지정된 기간에 대해 응답당 최대 500개의 결과를 조회할 수 있으며, 추가 데이터를 위해 페이지네이션할 수 있습니다. maxResults 매개변수를 사용해 표시 목적의 사용 사례에는 더 작은 페이지 크기(필요 시 사용자가 추가 결과를 요청 가능)로, 대용량 데이터 수집에는 더 큰 페이지 크기(최대 500)로 지정할 수 있습니다. 데이터는 최신순(내림차순)으로 제공되며, 제공 시점의 컴플라이언스를 준수합니다.

<div id="counts-requests-post-count">
  #### 카운트 요청(게시 수)
</div>

카운트 요청을 사용하면 지정한 기간 동안 특정 쿼리와 일치하는 활동이 얼마나 발생했는지에 대한 과거 활동 수를 조회할 수 있습니다. 응답은 본질적으로 일(day), 시간(hour), 또는 분(minute) 단위(기본 단위는 _hour_)로 버킷화된 카운트 히스토그램을 제공합니다. 카운트 결과는 게시가 이루어진 후 상당히 경과한 시점(7일 이상)에 발생하는 컴플라이언스 이벤트(예: 게시 삭제)를 항상 반영하지 않는다는 점에 유의하세요. 따라서 동일한 쿼리에 대한 데이터 요청 결과와 카운트 지표가 항상 일치하지 않을 수 있습니다.

**과금 안내:** 데이터 및 카운트 엔드포인트에 대한 각 요청( _페이지네이션 요청 포함_ )은 과금 대상 요청으로 계산됩니다. 따라서 단일 쿼리의 결과가 여러 페이지인 경우, X개의 결과 페이지를 순회하면 과금 기준으로 X건의 요청에 해당합니다.

<div id="available-operators">
  ### 사용 가능한 연산자
</div>

Enterprise 검색 API는 최대 2,048자의 규칙을 지원합니다. Enterprise 검색 API는 아래에 나열된 연산자를 지원합니다. 자세한 설명은 [여기](/ko/x-api/enterprise-gnip-2.0/fundamentals/search-api#enterprise-operators)를 참조하세요. 

|     |     |     |     |
| :--- | :--- | :--- | :--- |
| **게시물 콘텐츠 매칭:** | **관심 계정 매칭:** | **게시물 속성:** | **지리공간 연산자:** |
| \* 키워드<br />\* “인용구”<br />\* “keyword1 keyword2”~N<br />\* #<br />\* @<br />\* $<br />\* url:<br />\* lang: | \* from:<br />\* to:<br />\* retweets\_of: | \* is:retweet  <br />    <br />\* has:mentions<br />\* has:hashtags<br />\* has:media<br />\* has:videos<br />\* has:images<br />\* has:links<br />\* has:symbols<br />\* is:verified  <br />    <br />\* -is:nullcast (부정 전용 연산자) | \* bounding\_box:\[west\_long south\_lat east\_long north\_lat]<br />\* point\_radius:\[lon lat radius]<br />\* has:geo<br />\* place:<br />\* place\_country:<br />\* has:profile\_geo<br />\* profile\_country:<br />\* profile\_region:<br />\* profile\_locality: |

참고: 연산자를 중첩하거나 포함하지 마세요. "#cats"는 검색 API에서 cats로 해석됩니다. ‘lang:’ 연산자와 모든 ‘is:’ 및 ‘has:’ 연산자는 단독으로 사용할 수 없으며 다른 절과 결합해야 합니다(예: @XDevelopers has:links).    

검색 API는 토큰화/매칭 기능 때문에 제한된 연산자만 사용합니다. Enterprise 실시간 및 배치형 과거 API에서는 추가 연산자를 제공합니다. 자세한 내용은 [여기](/ko/x-api/enterprise-gnip-2.0/fundamentals/rules-filtering#operators-by-product)를 참조하세요.

자세한 내용은 [연산자 시작하기](/ko/x-api/enterprise-gnip-2.0/fundamentals/rules-filtering#building-rules-and-queries) 가이드를 참조하세요.

<div id="data-availability-important-date">
  ### 데이터 가용성 / 중요 날짜
</div>

전체 아카이브 검색 API를 사용할 때 X 플랫폼은 2006년 이후 지속적으로 발전해 왔다는 점을 염두에 두세요. 새로운 기능이 추가될 때마다 기본 JSON 객체에도 새로운 메타데이터가 추가되었습니다. 따라서 검색 연산자가 참조하는 게시물(Post) 속성이 언제 추가되었는지 이해하는 것이 중요합니다. 아래는 주요 메타데이터 그룹의 핵심 ‘도입일’입니다. 게시물 속성이 처음 도입된 시점에 대해 더 알아보려면 [이 가이드](/ko/x-api/enterprise-gnip-2.0/fundamentals/search-api#full-archive-search-metadata-timeline)를 참고하세요.  

- 최초 게시물(Post): 2006-03-21
- 최초 네이티브 리트윗: 2009-11-06
- 최초 지오태그된 게시물(Post): 2009-11-19
- 필터링용 URL 최초 색인: 2011-08-27
- 확장 URL 메타데이터 강화(웹사이트 제목 및 설명): 2014-12-01
- 프로필 지오(Geo) 보강 메타데이터 및 필터링: 2015-02-17

<div id="data-updates-and-mutability">
  ### 데이터 업데이트 및 변경 가능성
</div>

엔터프라이즈 검색 API에서는 게시물(Post) 내 일부 데이터가 변경 가능하며, 즉 초기 보관 이후에도 업데이트되거나 변경될 수 있습니다.

이 변경 가능한 데이터는 두 가지 범주로 나뉩니다:

- 사용자 객체 메타데이터:
  - 사용자의 @handle(숫자 ID는 절대 변경되지 않음)
  - 바이오 설명
  - 카운트: statuses, followers, friends, favorites, lists
  - 프로필 위치
  - 시간대 및 언어 등의 기타 세부 정보
- 게시물 통계 — 즉, 사용자 행동으로 플랫폼에서 변경될 수 있는 항목(아래 예시):
  - 즐겨찾기(favorites) 수
  - 리트윗(retweet) 수

대부분의 경우 검색 API는 게시물 생성 시점이 아닌 쿼리 시점에 플랫폼에 존재하는 데이터를 반환합니다. 다만 선택 연산자(예: from, to, @, is:verified)를 사용하는 쿼리의 경우에는 예외가 있을 수 있습니다. 데이터는 인덱스에서 정기적으로 업데이트되며, 최신 기간일수록 업데이트 빈도가 더 높습니다. 그 결과 일부 경우에는 반환된 데이터가 X.com에 표시되는 현재 데이터와 정확히 일치하지 않을 수 있으나, 마지막으로 인덱싱되었을 때의 데이터와 일치합니다.

참고로 이러한 불일치 문제는 연산자가 변경 가능한 데이터에 적용되는 쿼리에만 해당합니다. 예를 들어 사용자 이름을 기준으로 필터링하는 경우가 이에 해당하며, 가장 좋은 해결 방법은 해당 쿼리에서 @handle 대신 사용자 숫자 ID를 사용하는 것입니다.

<div id="single-vs-multi-threaded-requests">
  ### 단일 스레드 vs. 다중 스레드 요청
</div>

각 고객의 검색 엔드포인트에는 정해진 속도 제한이 있습니다. 전체 아카이브 검색의 기본 분당 속도 제한은 분당 120건으로, 평균 초당 2쿼리(QPS)에 해당합니다. 이 평균 QPS는 이론적으로 매초 API에 2개의 요청을 보낼 수 있음을 의미합니다. 제품의 페이지네이션 기능을 고려하면, 1년 범위의 쿼리에 연중 고르게 분포된 게시물 100만 건이 있는 경우 모든 데이터를 받기 위해서는(‘maxResults’를 500으로 가정) 2,000건이 넘는 요청이 필요합니다. 응답당 2초가 걸린다고 가정하면, 단일 스레드로 이전 응답의 “next” 토큰을 사용해 순차적으로 데이터를 가져올 때 약 4,000초(1시간 조금 넘음)가 소요됩니다. 나쁘지 않습니다!

이제 데이터를 수집하기 위해 12개의 병렬 스레드를 사용하는 상황을 생각해 보겠습니다. 100만 개의 게시물이 1년 동안 균등하게 분포되어 있다고 가정하면, 요청을 12개의 병렬 스레드(멀티스레드)로 나누어 단일 “작업”에 대해 초당 속도 제한을 더 효과적으로 활용할 수 있습니다. 즉, 관심 있는 각 월별로 스레드를 하나씩 실행하면 데이터를 12배 더 빠르게(약 6분) 가져올 수 있습니다.

이 멀티스레드 예시는 counts 엔드포인트에도 동일하게 적용됩니다. 예를 들어, 2년 기간의 게시물 수를 조회하려는 경우, 단일 스레드 요청으로 31일 단위로 페이지를 거슬러 올라가며 집계치를 받을 수 있습니다. 응답당 2초가 걸린다고 가정하면, 24건의 API 요청으로 전체 집계치를 가져오는 데 약 48초가 소요됩니다. 하지만 동시에 여러 개의 한 달 단위 요청을 보낼 수도 있습니다. 초당 12건의 요청을 보낼 경우, 전체 집계치를 약 2초 만에 가져올 수 있습니다.

<div id="retry-logic">
  ### 재시도 로직
</div>

엔터프라이즈 검색 API에서 503 오류가 발생하면 일시적인 문제일 가능성이 높으며, 잠시 후 요청을 다시 시도하면 해결될 수 있습니다.

요청이 연속으로 4회 실패했고 각 실패 사이에 최소 10분을 기다렸다면, 다음 단계를 통해 문제를 해결하세요:

- 요청이 포함하는 시간 범위를 줄인 뒤 다시 시도하세요. 실패할 경우 6시간 단위의 시간 창까지 반복해서 좁혀 보세요.
- 많은 수의 용어를 OR로 결합하고 있다면, 이를 별도의 규칙으로 분리하고 각 규칙을 개별적으로 다시 시도하세요.
- 규칙에 많은 제외 조건을 사용하고 있다면, 규칙의 부정(negation) 용어 수를 줄인 뒤 다시 시도하세요.

<div id="quick-start">
  ## 빠른 시작
</div>

<div id="getting-started-with-enterprise-search-posts-30-day-api">
  ### 엔터프라이즈 Search Posts: 30-Day API 시작하기
</div>

엔터프라이즈 Search Posts: 30-Day API는 최근 30일 이내에 게시된 포스트를 제공합니다. 포스트는 요청에 지정한 쿼리에 따라 매칭되어 반환됩니다. 쿼리는 반환받을 포스트가 어떤 내용을 포함해야 하는지를 정의하는 규칙입니다. 이 튜토리얼에서는 영어로 작성된 X 계정 @XDevelopers에서 작성된 포스트를 검색합니다.

페이로드로 반환되는 포스트는 전체 포스트 페이로드를 제공하는 data 형식이거나, 매칭된 포스트의 수치 집계 데이터를 제공하는 counts 형식일 수 있습니다. 우리는 cURL을 사용하여 data 및 counts 엔드포인트에 요청을 보낼 것입니다.

다음이 필요합니다:

- \[엔터프라이즈 계정]https://developer.x.com/en/products/x-api/enterprise
- 사용자 이름, 비밀번호, 계정 이름
- console.gnip.com에 표시되는 검색 엔드포인트와 연결된 레이블

<div id="accessing-the-data-endpoint">
  #### 데이터 엔드포인트 액세스
</div>

데이터 엔드포인트는 일치한 게시물의 전체 게시물 페이로드를 제공합니다. 영어로 작성된 @XDevelopers의 게시물을 찾기 위해 `from:` 및 `lang:` 연산자를 사용합니다. _더 많은 연산자는 [여기를 클릭](/ko/x-api/enterprise-gnip-2.0/fundamentals/search-api#enterprise-operators)하세요._

<Tabs>
  <Tab title="cURL">
    _cURL은 URL 구문을 사용해 파일을 가져오거나 전송하는 명령줄 도구입니다._

    아래 cURL 요청을 복사하기 전에 다음 값을 수정하세요:

    - **Username** `<USERNAME>` 예: `email@domain.com`

    - **Account name** `<ACCOUNT-NAME>` 예: `john-doe`

    - **Label** `<LABEL>` 예: `prod`

    - **fromDate and toDate** 예: `"fromDate":"201811010000", "toDate":"201811122359"`

    _요청을 전송하면 비밀번호 입력을 요구합니다._

    ```bash
    curl -X POST -u<USERNAME> "https://gnip-api.x.com/search/30day/accounts/<ACCOUNT-NAME>/<LABEL>.json" -d '{"query":"from:TwitterDev lang:en","maxResults":"500","fromDate":"<yyyymmddhhmm>","toDate":"<yyyymmddhhmm>"}'
    ```
  </Tab>

  <Tab title="cURL example">
    ```bash
    _다음은 예시 cURL 요청입니다. 그대로 실행해도 동작하지 않습니다._

    curl -X POST -uemail@domain.com "https://gnip-api.x.com/search/30day/accounts/john-doe/prod.json" -d '{"query":"from:TwitterDev lang:en","maxResults":"500","fromDate":"201811100000","toDate":"201812012359"}'
    ```
  </Tab>
</Tabs>

<div id="data-endpoint-response-payload">
  #### 데이터 엔드포인트 응답 페이로드
</div>

API 요청에 대한 응답 페이로드는 아래와 같이 JSON 형식으로 제공됩니다.

```json
{
	"results": [
		{
			"created_at": "Fri Nov 02 17:18:31 +0000 2018",
			"id": 1058408022936977409,
			"id_str": "1058408022936977409",
			"text": "RT @harmophone: \"Tagboard, Twitter, TEGNA의 협업이 가능하게 한 혁신적인 크라우드소싱은 지역과 관련된 대화를 발굴하고 있습…",
			"source": "<a href=\"http:\/\/twitter.com\" rel=\"nofollow\">Twitter 웹 클라이언트<\/a>",
			"truncated": false,
			"in_reply_to_status_id": null,
			"in_reply_to_status_id_str": null,
			"in_reply_to_user_id": null,
			"in_reply_to_user_id_str": null,
			"in_reply_to_screen_name": null,
			"user": {
				"id": 2244994945,
				"id_str": "2244994945",
				"name": "Twitter Dev",
				"screen_name": "TwitterDev",
				"location": "인터넷",
				"url": "https:\/\/developer.x.com\/",
				"description": "Twitter 플랫폼 뉴스, 업데이트 및 이벤트에 대한 공식 소식통입니다. 기술 지원이 필요하신가요? https:\/\/devcommunity.com\/ ⌨️ #TapIntoTwitter를 방문하세요",
				"translator_type": "null",
				"protected": false,
				"verified": true,
				"followers_count": 503828,
				"friends_count": 1477,
				"listed_count": 1437,
				"favourites_count": 2199,
				"statuses_count": 3380,
				"created_at": "Sat Dec 14 04:35:55 +0000 2013",
				"utc_offset": null,
				"time_zone": null,
				"geo_enabled": true,
				"lang": "en",
				"contributors_enabled": false,
				"is_translator": false,
				"profile_background_color": "null",
				"profile_background_image_url": "null",
				"profile_background_image_url_https": "null",
				"profile_background_tile": null,
				"profile_link_color": "null",
				"profile_sidebar_border_color": "null",
				"profile_sidebar_fill_color": "null",
				"profile_text_color": "null",
				"profile_use_background_image": null,
				"profile_image_url": "null",
				"profile_image_url_https": "https:\/\/pbs.twimg.com\/profile_images\/880136122604507136\/xHrnqf1T_normal.jpg",
				"profile_banner_url": "https:\/\/pbs.twimg.com\/profile_banners\/2244994945\/1498675817",
				"default_profile": false,
				"default_profile_image": false,
				"following": null,
				"follow_request_sent": null,
				"notifications": null
			},
			"geo": null,
			"coordinates": null,
			"place": null,
			"contributors": null,
			"retweeted_status": {
				"created_at": "Tue Oct 30 21:30:25 +0000 2018",
				"id": 1057384253116289025,
				"id_str": "1057384253116289025",
				"text": "\"Tagboard, Twitter, TEGNA의 협업이 가능하게 한 혁신적인 크라우드소싱은 지역과 관련된 주제를 발굴하고 있습… https:\/\/t.co\/w46U5TRTzQ",
				"source": "<a href=\"http:\/\/twitter.com\" rel=\"nofollow\">Twitter 웹 클라이언트<\/a>",
				"truncated": true,
				"in_reply_to_status_id": null,
				"in_reply_to_status_id_str": null,
				"in_reply_to_user_id": null,
				"in_reply_to_user_id_str": null,
				"in_reply_to_screen_name": null,
				"user": {
					"id": 175187944,
					"id_str": "175187944",
					"name": "Tyler Singletary",
					"screen_name": "harmophone",
					"location": "샌프란시스코, 캘리포니아",
					"url": "http:\/\/medium.com\/@harmophone",
					"description": "@Tagboard 제품 수석부사장(SVP). @Klout 및 @LithiumTech에서 데이터, 비즈니스, 제품을 담당; @BBI 이사회 멤버; @Insightpool 자문. 세계에서 화이트보드를 가장 못 쓰는 사람.",
					"translator_type": "null",
					"protected": false,
					"verified": false,
					"followers_count": 1982,
					"friends_count": 1877,
					"listed_count": 245,
					"favourites_count": 23743,
					"statuses_count": 12708,
					"created_at": "Thu Aug 05 22:59:29 +0000 2010",
					"utc_offset": null,
					"time_zone": null,
					"geo_enabled": false,
					"lang": "en",
					"contributors_enabled": false,
					"is_translator": false,
					"profile_background_color": "null",
					"profile_background_image_url": "null",
					"profile_background_image_url_https": "null",
					"profile_background_tile": null,
					"profile_link_color": "null",
					"profile_sidebar_border_color": "null",
					"profile_sidebar_fill_color": "null",
					"profile_text_color": "null",
					"profile_use_background_image": null,
					"profile_image_url": "null",
					"profile_image_url_https": "https:\/\/pbs.twimg.com\/profile_images\/719985428632240128\/WYFHcK-m_normal.jpg",
					"profile_banner_url": "https:\/\/pbs.twimg.com\/profile_banners\/175187944\/1398653841",
					"default_profile": false,
					"default_profile_image": false,
					"following": null,
					"follow_request_sent": null,
					"notifications": null
				},
				"geo": null,
				"coordinates": null,
				"place": null,
				"contributors": null,
				"is_quote_status": false,
				"extended_tweet": {
					"full_text": "\"Tagboard, Twitter, TEGNA의 협업으로 가능해진 혁신적인 크라우드소싱은 지역적으로 유의미한 대화를 실시간으로 포착하고, 토론 중 유권자가 질문할 수 있도록 합니다.\"  -- @adamostrow, @TEGNA\n자세히 보기: https:\/\/t.co\/ivAFtanfje",
					"display_text_range": [
						0,
						259
					],
					"entities": {
						"hashtags": [],
						"urls": [
							{
								"url": "https:\/\/t.co\/ivAFtanfje",
								"expanded_url": "https:\/\/blog.tagboard.com\/twitter-and-tagboard-collaborate-to-bring-best-election-content-to-news-outlets-with-tagboard-e85fc864bcf4",
								"display_url": "blog.tagboard.com\/twitter-and-ta…",
								"unwound": {
									"url": "https:\/\/blog.tagboard.com\/twitter-and-tagboard-collaborate-to-bring-best-election-content-to-news-outlets-with-tagboard-e85fc864bcf4",
									"status": 200,
									"title": "Twitter와 Tagboard, 최고의 선거 콘텐츠를 Tagboard와 함께 뉴스 매체에 제공하기 위해 협업…",
									"description": "Tagboard 제품 총괄 Tyler Singletary",
								},
								"indices": [
									236,
									259
								]
							}
						],
						"user_mentions": [
							{
								"screen_name": "adamostrow",
								"name": "Adam Ostrow",
								"id": 5695942,
								"id_str": "5695942",
								"indices": [
									204,
									215
								]
							},
							{
								"screen_name": "TEGNA",
								"name": "TEGNA",
								"id": 34123003,
								"id_str": "34123003",
								"indices": [
									217,
									223
								]
							}
						],
						"symbols": []
					}
				},
				"quote_count": 0,
				"reply_count": 1,
				"retweet_count": 6,
				"favorite_count": 19,
				"entities": {
					"hashtags": [],
					"urls": [
						{
							"url": "https:\/\/t.co\/w46U5TRTzQ",
							"expanded_url": "https:\/\/twitter.com\/i\/web\/status\/1057384253116289025",
							"display_url": "twitter.com\/i\/web\/status\/1…",
							"indices": [
								117,
								140
							]
						}
					],
					"user_mentions": [],
					"symbols": []
				},
				"favorited": false,
				"retweeted": false,
				"possibly_sensitive": false,
				"filter_level": "low",
				"lang": "en"
			},
			"is_quote_status": false,
			"quote_count": 0,
			"reply_count": 0,
			"retweet_count": 0,
			"favorite_count": 0,
			"entities": {
				"hashtags": [],
				"urls": [],
				"user_mentions": [
					{
						"screen_name": "harmophone",
						"name": "Tyler Singletary",
						"id": 175187944,
						"id_str": "175187944",
						"indices": [
							3,
							14
						]
					}
				],
				"symbols": []
			},
			"favorited": false,
			"retweeted": false,
			"filter_level": "low",
			"lang": "en",
			"matching_rules": [
				{
					"tag": null
				}
			]
		}
	],
	"requestParameters": {
		"maxResults": 100,
		"fromDate": "201811010000",
		"toDate": "201811060000"
	}
}
```

<div id="accessing-the-counts-endpoint">
  #### counts 엔드포인트 액세스
</div>

counts 엔드포인트를 사용하여 `day` 단위로 그룹화된, @XDevelopers 계정에서 영어로 게시된 Post 수를 조회합니다.

<Tabs>
  <Tab title="cURL">
    _cURL은 URL 구문을 사용해 파일을 가져오거나 전송하는 명령줄 도구입니다._

    아래 cURL 요청을 실행하기 전에 다음 값을 변경한 뒤 명령줄에 복사하세요:

    - **Username** `<USERNAME>` 예: `email@domain.com`

    - **Account name** `<ACCOUNT-NAME>` 예: `john-doe`

    - **Label** `<LABEL>` 예: `prod`

    - **fromDate 및 toDate** 예: `"fromDate":"201811010000", "toDate":"201811122359"`

    _요청을 전송하면 비밀번호 입력을 요청받습니다._

    ```bash
    curl -X POST -u<USERNAME> "https://gnip-api.x.com/search/30day/accounts/<ACCOUNT-NAME>/<LABEL>/counts.json" -d '{"query":"from:TwitterDev lang:en","fromDate":"<yyyymmddhhmm>","toDate":"<yyyymmddhhmm>","bucket":"day"}'
    ```
  </Tab>

  <Tab title="cURL example">
    _다음은 예시 cURL 요청입니다. 그대로 실행해도 동작하지 않습니다._

    ```bash
    curl -X POST -uemail@domain.com "https://gnip-api.x.com/search/30day/accounts/john-doe/prod/counts.json" -d '{"query":"from:TwitterDev lang:en","fromDate":"201811100000","toDate":"201812012359","bucket":"day"}'
    ```
  </Tab>
</Tabs>

<div id="counts-endpoint-response-payload">
  #### Counts 엔드포인트 응답 페이로드
</div>

아래 예시와 같이 API 요청에 대한 응답 페이로드는 JSON 형식으로 반환됩니다.

```json
{
	"results": [
		{
			"timePeriod": "201811010000",
			"count": 0
		},
		{
			"timePeriod": "201811020000",
			"count": 1
		},
		{
			"timePeriod": "201811030000",
			"count": 0
		},
		{
			"timePeriod": "201811040000",
			"count": 0
		},
		{
			"timePeriod": "201811050000",
			"count": 0
		}
	],
	"totalCount": 1,
	"requestParameters": {
		"bucket": "day",
		"fromDate": "201811010000",
		"toDate": "201811060000"
	}
}
```

잘하셨습니다! 이제 엔터프라이즈 Search Posts: 30-Day API에 성공적으로 액세스했습니다.

<div id="referenced-articles">
  ##### **참고 문서**
</div>

- [Post 객체 소개](/ko/x-api/enterprise-gnip-2.0/fundamentals/data-dictionary)
- [검색 연산자](/ko/x-api/enterprise-gnip-2.0/fundamentals/search-api#enterprise-operators)
- [Post 객체 및 페이로드](/ko/x-api/enterprise-gnip-2.0/fundamentals/data-dictionary#post-object)

<div id="getting-started-with-enterprise-search-posts-full-archive-api">
  ### 엔터프라이즈 Search Posts: Full-Archive API 시작하기
</div>

엔터프라이즈 Search Posts: Full-Archive API는 2006년 첫 게시물부터의 Post를 제공합니다. 요청에 지정한 쿼리를 기준으로 Post가 매칭되어 반환됩니다. 쿼리는 반환받을 Post에 어떤 내용이 포함되어야 하는지 정의하는 규칙입니다. 이 튜토리얼에서는 X 계정 @XDevelopers에서 영어로 게시된 Post를 검색합니다.

반환되는 Post는 전체 Post 페이로드를 제공하는 data 형식이거나, 매칭된 Post의 수치 집계 데이터를 제공하는 counts 형식일 수 있습니다. 우리는 cURL을 사용하여 data 및 counts 엔드포인트에 요청을 보냅니다.

다음이 필요합니다:

- \[엔터프라이즈 계정]https://developer.x.com/en/products/x-api/enterprise
- 사용자 이름, 비밀번호, 계정 이름
- console.gnip.com에 표시되는 검색 엔드포인트에 연관된 레이블

<div id="accessing-the-data-endpoint">
  #### 데이터 엔드포인트에 액세스하기
</div>

데이터 엔드포인트는 매칭된 게시물의 전체 게시물 페이로드를 제공합니다. `from:` 및 `lang:` 연산자를 사용하여 @XDevelopers에서 작성된 영어 게시물을 찾습니다. _더 많은 연산자는 [여기를 클릭](/ko/x-api/enterprise-gnip-2.0/fundamentals/search-api#enterprise-operators)하세요._

- [cURL](#tab1)
- [cURL example](#tab2)

<Tabs>
  <Tab title="cURL">
    _cURL은 URL 구문을 사용해 파일을 가져오거나 전송하는 명령줄 도구입니다._

    다음을 수정한 뒤 아래 cURL 요청을 명령줄에 복사하세요:

    - **Username** `<USERNAME>` 예: `email@domain.com`

    - **Account name** `<ACCOUNT-NAME>` 예: `john-doe`

    - **Label** `<LABEL>` 예: `prod`

    - **fromDate 및 toDate** 예: `"fromDate":"201802010000", "toDate":"201802282359"`

    _요청을 전송하면 비밀번호 입력을 요청받습니다._

    ```bash
    curl -X POST -u<USERNAME> "https://gnip-api.x.com/search/fullarchive/accounts/<ACCOUNT-NAME>/<LABEL>.json" -d '{"query":"from:TwitterDev lang:en","maxResults":"500","fromDate":"<yyyymmddhhmm>","toDate":"<yyyymmddhhmm>"}'
    ```
  </Tab>

  <Tab title="cURL example">
    _다음은 예시 cURL 요청입니다. 그대로 실행해도 작동하지 않습니다._

    ```bash
    curl -X POST -uemail@domain.com "https://gnip-api.x.com/search/fullarchive/accounts/john-doe/prod.json" -d '{"query":"from:TwitterDev lang:en","maxResults":"500","fromDate":"201802010000","toDate":"201802282359"}'
    ```
  </Tab>
</Tabs>

<div id="data-endpoint-response-payload">
  ##### 데이터 엔드포인트 응답 페이로드
</div>

API 요청에 대한 응답은 아래와 같이 JSON 형식으로 반환됩니다.

```json
{
	"results": [
		{
			"created_at": "Fri Nov 02 17:18:31 +0000 2018",
			"id": 1058408022936977409,
			"id_str": "1058408022936977409",
			"text": "RT @harmophone: \"Tagboard, Twitter, TEGNA의 협업이 가능하게 한 혁신적인 크라우드소싱은 지역 밀착형 대화를 이끌어내고 있습…",
			"source": "<a href=\"http:\/\/twitter.com\" rel=\"nofollow\">Twitter 웹 클라이언트<\/a>",
			"truncated": false,
			"in_reply_to_status_id": null,
			"in_reply_to_status_id_str": null,
			"in_reply_to_user_id": null,
			"in_reply_to_user_id_str": null,
			"in_reply_to_screen_name": null,
			"user": {
				"id": 2244994945,
				"id_str": "2244994945",
				"name": "Twitter Dev",
				"screen_name": "TwitterDev",
				"location": "Internet",
				"url": "https:\/\/developer.x.com\/",
				"description": "Twitter 플랫폼의 뉴스, 업데이트 및 이벤트에 대한 공식 채널입니다. 기술 지원이 필요하신가요? https:\/\/devcommunity.com\/ ⌨️ #TapIntoTwitter 를 방문하세요",
				"translator_type": "null",
				"protected": false,
				"verified": true,
				"followers_count": 503828,
				"friends_count": 1477,
				"listed_count": 1437,
				"favourites_count": 2199,
				"statuses_count": 3380,
				"created_at": "Sat Dec 14 04:35:55 +0000 2013",
				"utc_offset": null,
				"time_zone": null,
				"geo_enabled": true,
				"lang": "en",
				"contributors_enabled": false,
				"is_translator": false,
				"profile_background_color": "null",
				"profile_background_image_url": "null",
				"profile_background_image_url_https": "null",
				"profile_background_tile": null,
				"profile_link_color": "null",
				"profile_sidebar_border_color": "null",
				"profile_sidebar_fill_color": "null",
				"profile_text_color": "null",
				"profile_use_background_image": null,
				"profile_image_url": "null",
				"profile_image_url_https": "https:\/\/pbs.twimg.com\/profile_images\/880136122604507136\/xHrnqf1T_normal.jpg",
				"profile_banner_url": "https:\/\/pbs.twimg.com\/profile_banners\/2244994945\/1498675817",
				"default_profile": false,
				"default_profile_image": false,
				"following": null,
				"follow_request_sent": null,
				"notifications": null
			},
			"geo": null,
			"coordinates": null,
			"place": null,
			"contributors": null,
			"retweeted_status": {
				"created_at": "Tue Oct 30 21:30:25 +0000 2018",
				"id": 1057384253116289025,
				"id_str": "1057384253116289025",
				"text": "\"Tagboard, Twitter, TEGNA의 협업이 가능하게 한 혁신적인 크라우드소싱은 지역 밀착형 대화를 이끌어내고 있습… https:\/\/t.co\/w46U5TRTzQ",
				"source": "<a href=\"http:\/\/twitter.com\" rel=\"nofollow\">Twitter 웹 클라이언트<\/a>",
				"truncated": true,
				"in_reply_to_status_id": null,
				"in_reply_to_status_id_str": null,
				"in_reply_to_user_id": null,
				"in_reply_to_user_id_str": null,
				"in_reply_to_screen_name": null,
				"user": {
					"id": 175187944,
					"id_str": "175187944",
					"name": "Tyler Singletary",
					"screen_name": "harmophone",
					"location": "San Francisco, CA",
					"url": "http:\/\/medium.com\/@harmophone",
					"description": "@Tagboard의 제품 담당 수석 부사장(SVP). @Klout 및 @LithiumTech에서 데이터, 비즈니스, 제품 업무를 했으며, @BBI 이사회 멤버이자 @Insightpool 자문. 세계 최악의 화이트보딩 실력 보유자.",
					"translator_type": "null",
					"protected": false,
					"verified": false,
					"followers_count": 1982,
					"friends_count": 1877,
					"listed_count": 245,
					"favourites_count": 23743,
					"statuses_count": 12708,
					"created_at": "Thu Aug 05 22:59:29 +0000 2010",
					"utc_offset": null,
					"time_zone": null,
					"geo_enabled": false,
					"lang": "en",
					"contributors_enabled": false,
					"is_translator": false,
					"profile_background_color": "null",
					"profile_background_image_url": "null",
					"profile_background_image_url_https": "null",
					"profile_background_tile": null,
					"profile_link_color": "null",
					"profile_sidebar_border_color": "null",
					"profile_sidebar_fill_color": "null",
					"profile_text_color": "null",
					"profile_use_background_image": null,
					"profile_image_url": "null",
					"profile_image_url_https": "https:\/\/pbs.twimg.com\/profile_images\/719985428632240128\/WYFHcK-m_normal.jpg",
					"profile_banner_url": "https:\/\/pbs.twimg.com\/profile_banners\/175187944\/1398653841",
					"default_profile": false,
					"default_profile_image": false,
					"following": null,
					"follow_request_sent": null,
					"notifications": null
				},
				"geo": null,
				"coordinates": null,
				"place": null,
				"contributors": null,
				"is_quote_status": false,
				"extended_tweet": {
					"full_text": "\"Tagboard, Twitter, TEGNA의 협업을 통해 구현된 혁신적인 크라우드소싱은 지역 밀착형 대화를 실시간으로 드러내고, 토론 중 유권자가 질문할 수 있도록 합니다.\"  -- @adamostrow, @TEGNA\n자세히 보기: https:\/\/t.co\/ivAFtanfje",
					"display_text_range": [
						0,
						259
					],
					"entities": {
						"hashtags": [],
						"urls": [
							{
								"url": "https:\/\/t.co\/ivAFtanfje",
								"expanded_url": "https:\/\/blog.tagboard.com\/twitter-and-tagboard-collaborate-to-bring-best-election-content-to-news-outlets-with-tagboard-e85fc864bcf4",
								"display_url": "blog.tagboard.com\/twitter-and-ta…",
								"unwound": {
									"url": "https:\/\/blog.tagboard.com\/twitter-and-tagboard-collaborate-to-bring-best-election-content-to-news-outlets-with-tagboard-e85fc864bcf4",
									"status": 200,
									"title": "Twitter와 Tagboard, 협업을 통해 최고의 선거 콘텐츠를 Tagboard로 뉴스 매체에 제공…",
									"description": "Tagboard 제품 총괄 Tyler Singletary",
								},
								"indices": [
									236,
									259
								]
							}
						],
						"user_mentions": [
							{
								"screen_name": "adamostrow",
								"name": "Adam Ostrow",
								"id": 5695942,
								"id_str": "5695942",
								"indices": [
									204,
									215
								]
							},
							{
								"screen_name": "TEGNA",
								"name": "TEGNA",
								"id": 34123003,
								"id_str": "34123003",
								"indices": [
									217,
									223
								]
							}
						],
						"symbols": []
					}
				},
				"quote_count": 0,
				"reply_count": 1,
				"retweet_count": 6,
				"favorite_count": 19,
				"entities": {
					"hashtags": [],
					"urls": [
						{
							"url": "https:\/\/t.co\/w46U5TRTzQ",
							"expanded_url": "https:\/\/twitter.com\/i\/web\/status\/1057384253116289025",
							"display_url": "twitter.com\/i\/web\/status\/1…",
							"indices": [
								117,
								140
							]
						}
					],
					"user_mentions": [],
					"symbols": []
				},
				"favorited": false,
				"retweeted": false,
				"possibly_sensitive": false,
				"filter_level": "low"
				"lang": "en"
			},
			"is_quote_status": false,
			"quote_count": 0,
			"reply_count": 0,
			"retweet_count": 0,
			"favorite_count": 0,
			"entities": {
				"hashtags": [],
				"urls": [],
				"user_mentions": [
					{
						"screen_name": "harmophone",
						"name": "Tyler Singletary",
						"id": 175187944,
						"id_str": "175187944",
						"indices": [
							3,
							14
						]
					}
				],
				"symbols": []
			},
			"favorited": false,
			"retweeted": false,
			"filter_level": "low",
			"lang": "en",
			"matching_rules": [
				{
					"tag": null
				}
			]
		}
	],
	"requestParameters": {
		"maxResults": 100,
		"fromDate": "201811010000",
		"toDate": "201811060000"
	}
}
```

<div id="accessing-the-counts-endpoint">
  #### 카운트 엔드포인트에 액세스하기
</div>

카운트 엔드포인트를 사용해 @XDevelopers 계정에서 영어로 작성된 게시물의 수를 `day` 단위로 그룹화해 조회합니다.

<Tabs>
  <Tab title="cURL">
    _cURL은 URL 구문을 사용해 파일을 가져오거나 전송하는 명령줄 도구입니다._

    아래 cURL 요청을 실행하기 전에 다음 항목을 수정한 뒤 명령줄에 복사하세요:

    - **Username** `<USERNAME>` 예: `email@domain.com`

    - **Account name** `<ACCOUNT-NAME>` 예: `john-doe`

    - **Label** `<LABEL>` 예: `prod`

    - **fromDate and toDate** 예: `"fromDate":"201802010000", "toDate":"201802282359"`

    _요청을 전송하면 비밀번호 입력을 요청받습니다._

    ```bash
    curl -X POST -u<USERNAME> "https://gnip-api.x.com/search/fullarchive/accounts/<ACCOUNT-NAME>/<LABEL>/counts.json" -d '{"query":"from:TwitterDev lang:en","fromDate":"<yyyymmddhhmm>","toDate":"<yyyymmddhhmm>","bucket":"day"}'
    ```
  </Tab>

  <Tab title="cURL example">
    ```bash
    _다음은 예시 cURL 요청입니다. 그대로 실행해도 동작하지 않습니다._

    curl -X POST -uemail@domain.com "https://gnip-api.x.com/search/fullarchive/accounts/john-doe/prod/counts.json" -d '{"query":"from:TwitterDev lang:en","fromDate":"201802010000","toDate":"201802282359","bucket":"day"}'
    ```
  </Tab>
</Tabs>

<div id="counts-endpoint-response-payload">
  #### Counts 엔드포인트 응답 페이로드
</div>

아래 예시처럼 API 요청에 대한 응답 페이로드는 JSON 형식으로 반환됩니다.

```json
{
	"results": [
		{
			"timePeriod": "201811010000",
			"count": 0
		},
		{
			"timePeriod": "201811020000",
			"count": 1
		},
		{
			"timePeriod": "201811030000",
			"count": 0
		},
		{
			"timePeriod": "201811040000",
			"count": 0
		},
		{
			"timePeriod": "201811050000",
			"count": 0
		}
	],
	"totalCount": 1,
	"requestParameters": {
		"bucket": "day",
		"fromDate": "201811010000",
		"toDate": "201811060000"
	}
}
```

잘하셨습니다! 이제 엔터프라이즈 Search Posts: Full-Archive API에 성공적으로 접근하셨습니다.

##### 참고 문서

- [게시물 오브젝트 소개](/ko/x-api/enterprise-gnip-2.0/fundamentals/data-dictionary)
- [검색 연산자](/ko/x-api/enterprise-gnip-2.0/fundamentals/search-api#enterprise-operators)
- [게시물 오브젝트와 페이로드](/ko/x-api/enterprise-gnip-2.0/fundamentals/data-dictionary#post-object)

<div id="guides">
  ## 안내서
</div>

<div id="building-search-queries">
  ### 검색 쿼리 작성
</div>

<div id="enterprise-operators">
  ### 엔터프라이즈 연산자
</div>

아래는 X의 엔터프라이즈 검색 API에서 지원되는 모든 연산자 목록입니다:

- **Enterprise** 30일 검색 API
- **Enterprise** 전체 아카이브 검색 API

제품별로 사용 가능한 연산자를 나란히 비교하려면 [여기](/ko/x-api/enterprise-gnip-2.0/fundamentals/rules-filtering#operators-by-product)를 참조하세요.

|Operator|설명|
|:--------|:------------------|
| keyword      | 게시물 본문이나 URL에 포함된 토큰화된 키워드를 일치시킵니다. 토큰화 기반 일치로, 입력한 키워드 문자열을 게시물 본문의 토큰화된 텍스트와 비교합니다. 토큰화는 구두점, 기호, 구분자에 해당하는 유니코드 기본 평면 문자를 기준으로 수행됩니다. 예를 들어 “I like coca-cola”라는 텍스트가 있는 게시물은 I, like, coca, cola와 같은 토큰으로 분리됩니다. 이렇게 분리된 토큰이 규칙에서 사용한 키워드 문자열과 비교됩니다. 구두점(예: coca-cola), 기호, 구분자 문자를 포함하는 문자열을 일치시키려면 아래에 설명된 대로 큰따옴표를 사용한 정확 일치를 사용해야 합니다.<br /><br />**참고:** Search API에서는 악센트 및 특수 문자가 표준 라틴 문자로 정규화되므로 외국어에서 의미가 변하거나 예상치 못한 결과가 반환될 수 있습니다:<br />예: "músic"은 “music”과 서로 일치합니다.<br />예: 스페인어의 "Feliz Año Nuevo!"와 같은 일반적인 문구는 "Feliz Ano Nuevo"로 색인되어 문구의 의미가 달라집니다.<br /><br />**참고:** 이 연산자는 게시물 내의 URL과 언와인드된 URL 모두에 대해 일치합니다.                |
|emoji|게시물 본문에 포함된 이모지를 일치시킵니다. 이모지는 토큰화 기반 일치로, 입력한 이모지를 게시물 본문의 토큰화된 텍스트와 비교합니다. 토큰화는 구두점, 기호/이모지, 구분자에 해당하는 유니코드 기본 평면 문자를 기준으로 수행됩니다. 예를 들어 “I like <Icon icon="pizza-slice" iconType="solid" />”라는 텍스트가 있는 게시물은 I, like, <Icon icon="pizza-slice" iconType="solid" />와 같은 토큰으로 분리됩니다. 이렇게 분리된 토큰이 규칙에서 사용한 이모지와 비교됩니다. 이모지에 변형이 있는 경우 규칙에 추가하려면 반드시 큰따옴표를 사용해야 합니다. |
|"exact phrase match" |게시물 본문이나 URL에 포함된 토큰화되고 순서가 유지된 구문을 일치시킵니다. 이는 토큰화 기반 일치로, 입력한 키워드 문자열을 게시물 본문의 토큰화된 텍스트와 비교합니다. 토큰화는 구두점, 기호, 구분자에 해당하는 유니코드 기본 평면 문자를 기준으로 수행됩니다. <br /><br />**참고:** 구두점은 토큰화되지 않으며 공백으로 처리됩니다.<br />예: 큰따옴표로 감싼 “#hashtag”는 “hashtag”와는 일치하지만 #hashtag와는 일치하지 않습니다(실제 해시태그와 일치시키려면 큰따옴표 없이 해시태그 # 연산자를 사용하세요).<br />예: 큰따옴표로 감싼 “$cashtag”는 “cashtag”와는 일치하지만 $cashtag와는 일치하지 않습니다(실제 캐시태그와 일치시키려면 큰따옴표 없이 캐시태그 $ 연산자를 사용하세요).<br />예: "Love Snow"는 "#love #snow"와 일치합니다.<br />예: "#Love #Snow"는 "love snow"와 일치합니다.<br /><br />**참고:** 이 연산자는 게시물 내의 URL과 언와인드된 URL 모두에 대해 일치합니다.|
|"keyword1 keyword2"~N|일반적으로 근접 연산자라 하며, 키워드들이 서로 최대 N개의 토큰 이내에 있을 때 게시물과 일치합니다. <br /><br />키워드의 순서가 반대인 경우 서로 최대 N-2 토큰 이내여야 합니다. 큰따옴표 안에는 임의의 개수의 키워드를 사용할 수 있습니다. N은 6을 초과할 수 없습니다.<br /><br />이 연산자는 `enterprise` 검색 API에서만 사용할 수 있습니다.|
|from:| 특정 사용자의 게시물과 일치시킵니다.<br />값은 해당 사용자의 X 숫자 계정 ID 또는 사용자명(@ 문자는 제외)이어야 합니다. 숫자형 X 계정 ID 조회 방법은 [HERE](/ko/x-api/users/lookup/introduction) 또는 [HERE](http://gettwitterid.com/)를 참조하세요.|
|to:|특정 사용자에게 회신한 게시물과 일치시킵니다.<br /><br />값은 해당 사용자의 숫자 계정 ID 또는 사용자명(@ 문자는 제외)이어야 합니다. 숫자형 X 계정 ID 조회 방법은 [HERE](/ko/x-api/users/lookup/introduction)를 참조하세요.|
|url:|게시물의 확장된 URL에서 토큰화(키워드/구문)된 일치를 수행합니다(url\_contains와 유사). 구두점이나 특수 문자가 포함된 토큰과 구문은 큰따옴표로 감싸야 합니다. 예: url:"/developer". 일반적으로 권장하지 않지만, 특정 프로토콜까지 일치시키려면 큰따옴표로 감싸세요: url:"https://developer.x.com".<br />**참고:** PowerTrack 또는 Historical PowerTrack을 사용할 때, 이 연산자는 인용 게시물의 원본 게시물에 포함된 URL에도 일치합니다. 예를 들어 규칙에 url:"developer.x.com"이 포함되어 있고 어떤 게시물에 해당 URL이 포함되어 있다면, 그 게시물을 인용한 모든 인용 트윗도 결과에 포함됩니다. Search API를 사용할 때는 해당되지 않습니다.|
|#|지정한 해시태그가 포함된 모든 게시물과 일치합니다.<br /><br />이 연산자는 토큰화된 일치가 아닌 정확한 일치를 수행하므로, 규칙 “2016”은 해시태그 “2016”이 있는 게시물과만 일치하며 “2016election” 해시태그가 있는 게시물과는 일치하지 않습니다.<br /><br />참고: 해시태그 연산자는 본문에서 직접 해시태그를 추출하는 대신 X의 엔터티 추출을 사용해 해시태그를 일치시킵니다. X 엔터티 JSON 속성에 대한 자세한 내용은 [여기](/ko/x-api/enterprise-gnip-2.0/fundamentals/data-dictionary#hashtags)를 참조하세요.|
|@|지정한 사용자명을 언급한 모든 게시물과 일치합니다.<br />to: 연산자는 @언급 연산자의 부분 집합을 반환합니다.|
|$|지정한 ‘캐시태그’(토큰의 첫 문자가 ‘$’인 경우)가 포함된 모든 게시물과 일치합니다.<br /><br />캐시태그 연산자는 본문에서 캐시태그를 직접 추출하려는 대신 X의 ‘symbols’ 엔터티 추출을 사용해 캐시태그를 일치시킵니다. X 엔터티 JSON 속성에 대한 자세한 내용은 [여기](/ko/x-api/enterprise-gnip-2.0/fundamentals/data-dictionary#symbols)를 참조하세요.<br /><br />이 연산자는 `enterprise` 검색 API에서만 제공됩니다.<br /><br />|
|retweets\_of:|_사용 가능한 별칭_: retweets\_of\_user:<br />지정한 사용자의 리트윗인 게시물과 일치합니다. 사용자명과 숫자 X 계정 ID(게시물 상태 ID가 아님) 모두를 허용합니다. 숫자 X 계정 ID 조회 방법은 [여기](/ko/x-api/users/lookup/introduction)를 참조하세요.|
|lang:|X가 특정 언어로 분류한 게시물(게시물이 분류된 경우에 한함)과 일치합니다. 각 게시물은 현재 하나의 언어로만 분류되므로 여러 언어를 AND로 결합하면 결과가 나오지 않습니다.<br /><br />**참고:** 언어 분류를 할 수 없는 경우 제공되는 결과는 ‘und’(미정의)입니다.<br /><br />아래 목록은 현재 지원되는 언어와 해당 BCP 47 언어 식별자를 나타냅니다:<br />|

|     |     |     |     |
| :--- | :--- | :--- | :--- |
| 암하라어: am | 독일어: de | 말라얄람어: ml | 슬로바키아어: sk |
| 아랍어: ar | 그리스어: el | 디베히어(몰디브어): dv | 슬로베니아어: sl |
| 아르메니아어: hy | 구자라트어: gu | 마라티어: mr | 소라니 쿠르드어: ckb |
| 바스크어: eu | 아이티 크리올어: ht | 네팔어: ne | 스페인어: es |
| 벵골어: bn | 헤브루어: iw | 노르웨이어: no | 스웨덴어: sv |
| 보스니아어: bs | 힌디어: hi | 오디아어(오리야어): or | 타갈로그어: tl |
| 불가리아어: bg | 라틴 문자 힌디어: hi-Latn | 펀자브어: pa | 타밀어: ta |
| 버마어(미얀마어): my | 헝가리어: hu | 파슈토어: ps | 텔루구어: te |
| 크로아티아어: hr | 아이슬란드어: is | 페르시아어: fa | 태국어: th |
| 카탈루냐어: ca | 인도네시아어: in | 폴란드어: pl | 티베트어: bo |
| 체코어: cs | 이탈리아어: it | 포르투갈어: pt | 번체 중국어: zh-TW |
| 덴마크어: da | 일본어: ja | 루마니아어: ro | 터키어: tr |
| 네덜란드어: nl | 칸나다어: kn | 러시아어: ru | 우크라이나어: uk |
| 영어: en | 크메르어: km | 세르비아어: sr | 우르두어: ur |
| 에스토니아어: et | 한국어: ko | 간체 중국어: zh-CN | 위구르어: ug |
| 핀란드어: fi | 라오어: lo | 신디어: sd | 베트남어: vi |
| 프랑스어: fr | 라트비아어: lv | 싱할라어: si | 웨일스어: cy |
| 조지아어: ka | 리투아니아어: lt |     |

|||
|:----|:---|
|place:|지정한 위치 또는 X place ID가 태그된 게시물과 일치합니다(예시 참조). 여러 단어로 된 장소 이름(“New York City”, “Palo Alto”)은 따옴표로 감싸야 합니다.<br /><br />**참고:** X place ID를 얻는 방법은 [GET geo/search](https://developer.x.com/en/docs/x-api/v1/geo/place-information/overview) 공개 API 엔드포인트를 참조하세요.<br /><br />**참고:** 이 연산자는 리트윗에는 일치하지 않습니다. 리트윗의 장소 정보는 원본 게시물에 연결되기 때문입니다. 또한 인용 트윗의 원본 게시물에 연결된 장소에도 일치하지 않습니다.|
|place\_country:|태그된 [place](https://developer.x.com/en/docs/x-api/v1/geo/place-information/overview)에 연관된 국가 코드가 지정한 ISO 알파-2 문자 코드와 일치하는 게시물과 매칭됩니다.<br /><br />유효한 ISO 코드는 여기에서 확인할 수 있습니다: [http://en.wikipedia.org/wiki/ISO\_3166-1\_alpha-2](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)<br /><br />**참고:** 이 연산자는 리트윗에는 일치하지 않습니다. 리트윗의 장소 정보는 원본 게시물에 연결되기 때문입니다. 또한 인용 트윗의 원본 게시물에 연결된 장소에도 일치하지 않습니다.|
|point\_radius:\[lon lat radius]|존재하는 경우 게시물의 정확한 위치(x, y)와, X에서는 “Place” 지오 폴리곤에 대해 매칭합니다. 이때 Place는 정의된 영역에 완전히 포함되어 있어야 합니다.<br /><br />\* 지원되는 반지름 단위는 마일(mi)과 킬로미터(km)입니다.<br />\* 반지름은 25mi 미만이어야 합니다.<br />\* 경도 범위는 ±180입니다.<br />\* 위도 범위는 ±90입니다.<br />\* 모든 좌표는 십진 도(deg) 단위입니다.<br />\* 규칙 인수는 대괄호로 감싸고 공백으로 구분합니다.<br /><br />**참고:** 이 연산자는 리트윗에는 일치하지 않습니다. 리트윗의 장소 정보는 원본 게시물에 연결되기 때문입니다. 또한 인용 트윗의 원본 게시물에 연결된 장소에도 일치하지 않습니다.|
|bounding\_box:\[west\_long south\_lat east\_long north\_lat]|_사용 가능한 별칭_: geo\_bounding\_box:<br /><br />존재하는 경우 게시물의 정확한 위치(경도, 위도)와, X에서는 “Place” 지오 폴리곤에 대해 매칭합니다. 이때 Place는 정의된 영역에 완전히 포함되어 있어야 합니다.<br /><br />\* west\_long과 south\_lat는 경계 상자의 남서쪽 모서리를 나타내며, west\_long은 해당 지점의 경도, south\_lat는 위도를 의미합니다.<br />\* east\_long과 north\_lat는 경계 상자의 북동쪽 모서리를 나타내며, east\_long은 해당 지점의 경도, north\_lat는 위도를 의미합니다.<br />\* 경계 상자의 너비와 높이는 25mi 미만이어야 합니다.<br />\* 경도 범위는 ±180입니다.<br />\* 위도 범위는 ±90입니다.<br />\* 모든 좌표는 십진 도(deg) 단위입니다.<br />\* 규칙 인수는 대괄호로 감싸고 공백으로 구분합니다.<br />**참고:** 이 연산자는 리트윗에는 일치하지 않습니다. 리트윗의 장소 정보는 원본 게시물에 연결되기 때문입니다. 또한 인용 트윗의 원본 게시물에 연결된 장소에도 일치하지 않습니다.
|profile\_country:|Profile Geo enrichment의 “address” 객체에 있는 “countryCode” 필드와 정확히 일치합니다.<br />ISO-3166-1-alpha-2 사양을 기반으로 표준화된 두 글자 국가 코드 집합을 사용합니다. 간결성을 위해 “address” 객체의 “country” 필드용 연산자 대신 이 연산자를 제공합니다.|
|profile\_region:|Profile Geo enrichment의 “address” 객체에 있는 “region” 필드와 일치합니다.<br /><br />정확한 전체 문자열 일치입니다. 백슬래시로 문자를 이스케이프할 필요가 없습니다. 예를 들어 슬래시가 포함된 값을 일치시키려면 “one/two”를 사용하고 “one\\/two”는 사용하지 마세요. 공백이나 문장 부호가 포함된 부분 문자열을 일치시키려면 큰따옴표를 사용하세요.|
|profile\_locality:|Profile Geo enrichment의 “address” 객체에 있는 “locality” 필드와 일치합니다.<br /><br />정확한 전체 문자열 일치입니다. 백슬래시로 문자를 이스케이프할 필요가 없습니다. 예를 들어 슬래시가 포함된 값을 일치시키려면 “one/two”를 사용하고 “one\\/two”는 사용하지 마세요. 공백이나 문장 부호가 포함된 부분 문자열을 일치시키려면 큰따옴표를 사용하세요.|

<Info>
  **참고:** Search API에서는 is: 및 has: 연산자를 단독으로 사용할 수 없으며, 반드시 다른 절과 함께 사용해야 합니다.

  예: @XDeevelopers has:links
</Info>

|     |     |
| :--- | :--- |
| has:geo | X에서 제공하는 게시물별 지리 위치 데이터가 있는 게시물과 일치합니다. 이것은 “geo” 위도/경도 좌표이거나, 표시 이름, 지리 폴리곤 및 기타 필드가 포함된 X의 [“Place”](https://dev.x.com/overview/api/places) 형태의 “location”일 수 있습니다.<br /><br />  <br /><br />**참고:** Search API를 사용할 때 이 연산자는 `is:` 또는 `has:`를 포함하지 않는 다른 연산자와 함께 사용해야 합니다. |
| has:profile\_geo | _사용 가능한 별칭_: has:derived\_user\_geo<br /><br />실제 값과 관계없이 [Profile Geo](http://support.gnip.com/enrichments/profile_geo.html) 메타데이터가 있는 게시물과 일치합니다.  <br />  <br /><br />**참고:** Search API를 사용할 때 이 연산자는 `is:` 또는 `has:`를 포함하지 않는 다른 연산자와 함께 사용해야 합니다. |
| has:links | 메시지 본문에 링크가 포함된 게시물과 일치합니다.  <br />  <br /><br />**참고:** Search API를 사용할 때 이 연산자는 `is:` 또는 `has:`를 포함하지 않는 다른 연산자와 함께 사용해야 합니다. |
| is:retweet | 규칙과 일치하는 명시적 리트윗만 전달합니다. 규칙과 일치하는 리트윗을 제외하도록 부정하여 원본 콘텐츠만 전달할 수도 있습니다.<br /><br />이 연산자는 X의 리트윗 기능을 사용하는 실제 리트윗만 찾습니다. 인용 트윗과 X의 리트윗 기능을 사용하지 않는 수정된 게시물은 이 연산자로 매치되지 않습니다.<br /><br />  <br /><br />**참고:** Search API를 사용할 때 이 연산자는 `is:` 또는 `has:`를 포함하지 않는 다른 연산자와 함께 사용해야 합니다. |
| is:reply | 게시물이 다른 게시물에 대한 답글인지 여부로 필터링하는 연산자입니다. 규칙과 일치하는 명시적 답글만 전달합니다. 규칙과 일치하는 답글을 제외하도록 부정할 수도 있습니다.<br /><br />이 연산자는 유료 프리미엄 및 엔터프라이즈 검색에서만 제공되며, Sandbox 개발 환경에서는 제공되지 않습니다.<br /><br />  <br /><br />**참고:** Search API를 사용할 때 이 연산자는 `is:` 또는 `has:`를 포함하지 않는 다른 연산자와 함께 사용해야 합니다. |
| is:quote | 인용 트윗 또는 다른 게시물을 참조하는 게시물만 전달합니다. 게시물 페이로드의 "is\_quote\_status":true로 식별됩니다. 인용 트윗을 제외하도록 부정할 수도 있습니다.  <br /><br />**참고:** Search API를 사용할 때 이 연산자는 `is:` 또는 `has:`를 포함하지 않는 다른 연산자와 함께 사용해야 합니다. |
| is:verified | 작성자가 X에서 “인증됨”인 게시물만 전달합니다. 작성자가 인증된 게시물을 제외하도록 부정할 수도 있습니다.  <br />  <br /><br />**참고:** Search API를 사용할 때 이 연산자는 `is:` 또는 `has:`를 포함하지 않는 다른 연산자와 함께 사용해야 합니다. |
| has:mentions | 다른 X 사용자를 언급한 게시물과 일치합니다.  <br />  <br /><br />**참고:** Search API를 사용할 때 이 연산자는 `is:` 또는 `has:`를 포함하지 않는 다른 연산자와 함께 사용해야 합니다. |
| has:hashtags | 해시태그가 포함된 게시물과 일치합니다.  <br />  <br /><br />**참고:** Search API를 사용할 때 이 연산자는 `is:` 또는 `has:`를 포함하지 않는 다른 연산자와 함께 사용해야 합니다. |
| has:media | _사용 가능한 별칭_: has:media\_link<br /><br />X에서 분류한 미디어 URL이 포함된 게시물과 일치합니다. 예: pic.x.com.  <br />  <br /><br />**참고:** Search API를 사용할 때 이 연산자는 `is:` 또는 `has:`를 포함하지 않는 다른 연산자와 함께 사용해야 합니다. |
| has:images | X에서 분류한 미디어 URL이 포함된 게시물과 일치합니다. 예: pic.x.com.  <br />  <br /><br />**참고:** Search API를 사용할 때 이 연산자는 `is:` 또는 `has:`를 포함하지 않는 다른 연산자와 함께 사용해야 합니다. |
| has:videos | _사용 가능한 별칭_: has:video\_link<br /><br />X에 직접 업로드된 네이티브 X 동영상이 포함된 포스트와 일치합니다. Vine, Periscope로 만든 동영상이나 다른 동영상 호스팅 사이트로 연결되는 링크가 있는 포스트와는 일치하지 않습니다.  <br />  <br /><br />**참고:** Search API를 사용할 때 이 연산자는 `is:` 또는 `has:`가 포함되지 않은 다른 연산자와 함께 사용해야 합니다. |
| has:symbols | 선행 ‘$’ 문자가 있는 캐시태그가 포함된 포스트와 일치합니다(예: $tag). 이 연산자는 `enterprise` 검색 API에서만 사용할 수 있습니다.  <br />  <br /><br />**참고:** Search API를 사용할 때 이 연산자는 `is:` 또는 `has:`가 포함되지 않은 다른 연산자와 함께 사용해야 합니다. |

<div id="product-overview">
  ### 제품 개요
</div>

엔터프라이즈 티어의 전체 아카이브 검색은 2015년 8월에, 프리미엄 티어 버전은 2018년 2월에 출시되었습니다. 이 검색 제품은 고객이 공개적으로 이용 가능한 모든 게시물에 즉시 접근할 수 있도록 합니다. 전체 아카이브 검색에서는 단일 쿼리를 제출하고 표준적인 RESTful 방식으로 응답을 받습니다. 전체 아카이브 검색은 응답당 최대 500개 게시물의 페이지네이션을 구현하며, 프리미엄은 분당 최대 60회(rpm), 엔터프라이즈는 분당 120회(rpm)까지의 레이트 리밋을 지원합니다. 이러한 점을 고려하면 전체 아카이브 검색은 게시물을 신속하게, 그리고 동시 요청을 통해 대규모로 조회하는 데 적합합니다.

디스크에 저장된 게시물 플랫 파일 집합을 기반으로 하는 Historical PowerTrack과 달리, 전체 아카이브 검색의 게시물 아카이브는 온라인 데이터베이스와 유사합니다. 모든 데이터베이스와 마찬가지로 콘텐츠에 대한 쿼리를 지원하며, 고성능 데이터 검색을 위한 인덱스를 활용합니다. 전체 아카이브 검색 엔드포인트에서는 쿼리 언어가 PowerTrack 연산자로 구성되며, 각 연산자는 인덱싱된 게시물 JSON 속성에 대응합니다.

또한 Historical PowerTrack과 마찬가지로, 쿼리를 수행하는 시점의 최신 상태를 반영하는 게시물 속성들이 있습니다. 예를 들어, 오늘 Search API로 2010년에 게시된 게시물을 조회하면, 사용자의 프로필 설명, 계정 ‘home’ 위치, 표시 이름, 즐겨찾기 및 리트윗 수와 같은 게시물 지표는 2010년 당시가 아닌 오늘 기준의 값으로 업데이트되어 반환됩니다. 

<div id="metadata-timelines">
  ### 메타데이터 타임라인
</div>

아래는 전체 아카이브 검색 엔드포인트의 연산자(Operator)가 매칭을 시작한 시점에 대한 타임라인입니다. 일부 경우에는 연산자 매칭이 X에서 ‘커뮤니케이션 관례’가 널리 자리 잡은 후에야 시작되었습니다. 예를 들어, @Replies는 2006년에 사용자 관례로 등장했지만, ‘지원하는’ JSON과 함께 _일급 객체_ 또는 \_이벤트\_로 취급되기 시작한 것은 2007년 초였습니다. 따라서 2006년에 @Replies를 매칭하려면 `to:` 및 `in_reply_to_status_id:` PowerTrack 연산자에 의존하기보다 게시물 본문을 검사해야 합니다.

여기에 제공된 세부 정보는 전체 아카이브 검색(수백 건의 검색을 수행한 결과)을 통해 도출되었습니다. 이 타임라인은 100% 완전하거나 정확하지 않을 수 있습니다. 사용 사례에 핵심적인 다른 필터링/메타데이터의 “도입일”을 확인하신 경우 알려주시기 바랍니다.

기본 검색 인덱스는 재구축될 수 있습니다. 따라서 이 타임라인의 세부 정보는 변경될 수 있습니다.

<div id="2006">
  #### 2006
</div>

- 3월 26일 - `lang:`. 검색 인덱스를 생성하는 동안 게시물 메타데이터를 소급 보강(backfill)한 사례.
- 7월 13일 - `has:mentions` 일치 시작.
- 10월 6일 - `has:symbols`. 주식 심볼 논의를 위한 $캐시태그(또는 심볼)는 2009년 초까지는 흔하지 않았습니다. 그전까지의 대부분 사용은 아마도 속어였을 것입니다(예: $slang).
- 10월 26일 - `has:links` 일치 시작.
- 11월 23일 - `has:hashtags` 일치 시작.

<div id="2007">
  #### 2007
</div>

- 1월 30일 - 최초의 일급 @reply(in\_reply\_to\_user\_id), `reply_to_status_id:` 매칭 시작.
- 8월 23일 - 해시태그가 주제와 대화를 정리하는 일반적인 관례로 등장. 실제 첫 사용은 일주일 후.

<div id="2009">
  #### 2009
</div>

- 5월 15일 - `is:retweet`. 이 연산자는 공식 리트윗의 ‘베타’ 출시와 “Via @” 패턴 도입 시점부터 일치하기 시작합니다. 이 베타 기간 동안 Post의 동사는 ‘post’이며, 원본 Post는 페이로드에 포함되지 않습니다.
- 8월 13일 - 공식 리트윗의 최종 버전이 “RT @” 패턴, 동사를 ‘share’로 설정, 그리고 원본 Post를 포함하는 ‘retweet\_status’ 속성과 함께 출시됩니다(이에 따라 JSON 페이로드 크기가 대략 두 배가 됩니다).

<div id="2010">
  #### 2010
</div>

- 3월 6일 - `has:geo`, `bounding_box:`, `point_radius:` 지리 연산자 매칭 시작.
- 8월 28일 - `has:videos` (2015년 2월까지 이 연산자는 youtube.com, vimeo.com, vivo.com 등 일부 동영상 호스팅 사이트 링크가 포함된 게시물을 매칭함).

<div id="2011">
  #### 2011
</div>

- 7월 20일 - `has:media` 및 `has:images`가 매칭되기 시작합니다. 네이티브 사진은 2010년 8월 9일 공식적으로 발표되었습니다.

<div id="2014">
  #### 2014
</div>

- 12월 3일 - (대략) HTML 제목과 설명이 포함된 _일부_ [강화된 URL 메타데이터](/ko/x-api/enterprise-gnip-2.0/fundamentals/data-enrichments)가 페이로드에 등장하기 시작했습니다. 강화된 메타데이터는 2016년 5월에 보다 완전한 형태로 자리잡았습니다.

<div id="2015">
  #### 2015
</div>

- 2월 10일 - `has:videos`가 ‘네이티브’ X 동영상을 매칭합니다.
- 2월 17일 - `has:profile_geo`, `profile_country:`, `profile_region:`, `profile_locality:` [Profile Geo](/ko/x-api/enterprise-gnip-2.0/fundamentals/data-enrichments#profile-geo) 연산자가 매칭되기 시작합니다.
- 2월 17일 - `place_country:` 및 `place:` 게시물 지오 연산자가 매칭되기 시작합니다.

<div id="2016">
  #### 2016
</div>

- 5월 1일 - [강화된 URL 메타데이터](/ko/x-api/enterprise-gnip-2.0/fundamentals/data-enrichments)가 더 폭넓게 제공되었으며, [2016년 8월 Gnip 2.0 출시](https://blog.x.com/2016/gnip-2-is-here)와 함께 공식 발표되었습니다. Search API에는 해당 메타데이터를 위한 연관 연산자(Operator)가 없습니다.

<div id="2017">
  #### 2017
</div>

- 2월 22일 - 투표 메타데이터가 확장된 네이티브 형식으로 제공됩니다. 이 메타데이터와 관련된 오퍼레이터는 없습니다.

<div id="2022">
  #### 2022
</div>

- 9월 27일 - 이 날짜 이후에 생성된 모든 Post 객체에는 편집 Post 메타데이터가 제공됩니다. Post 객체를 제공하는 모든 Enterprise 엔드포인트도 이 날짜부터 해당 메타데이터를 제공하도록 업데이트되었습니다. 제공되는 편집 메타데이터에는 edit\_history 및 edit\_controls 객체가 포함됩니다. 이러한 메타데이터는 2022년 9월 27일 이전에 생성된 Post에는 반환되지 않습니다. 현재 이 메타데이터와 일치하는 Enterprise 연산자는 없습니다. 편집 Post 메타데이터에 대해 자세히 알아보려면 [Edit Posts 기본 사항](/ko/x-api/fundamentals/edit-posts) 페이지를 확인하세요.

<div id="2022">
  #### 2022
</div>

- 9월 29일 - 이날 이후에 생성된 모든 Post 객체에는 편집 Post 메타데이터가 제공됩니다. Post 객체를 제공하는 모든 Enterprise 엔드포인트도 이날부터 해당 메타데이터를 제공하도록 업데이트되었습니다. 제공되는 편집 메타데이터에는 edit\_history 및 edit\_controls 객체가 포함됩니다. 이 메타데이터는 2022년 9월 27일 이전에 생성된 Post에는 반환되지 않습니다. 현재 이러한 메타데이터에 대응하는 Enterprise Operator는 제공되지 않습니다. Edit Post 메타데이터에 대해 더 알아보려면 [Edit Posts fundamentals](/ko/x-api/fundamentals/edit-posts) 페이지를 확인하세요.

<div id="filtering-tips">
  ### 필터링 팁
</div>

앞서 설명한 타임라인 정보를 종합하면 Search API 필터를 작성할 때 고려해야 할 세부 사항이 많다는 점이 분명합니다. 핵심적으로 고려할 사항은 두 가지입니다.

- 일부 메타데이터에는 ‘생성 시점’이 있어 필터가 _거짓 음성(false negatives)_ 을 낳을 수 있습니다. 이는 검색 기간 전체 또는 일부에 존재하지 않았던 메타데이터에 의존하는 연산자(Operator)를 사용하는 경우입니다. 예를 들어 `has:images` 연산자로 게시물을 검색하면 2011년 7월 이전 기간에는 일치 항목이 없습니다. 해당 연산자가 _네이티브_ 사진(X 사용자 인터페이스를 통해 게시물에 첨부된 사진)에만 매칭되기 때문입니다. 사진 공유 게시물의 보다 완전한 데이터 세트를 얻으려면 2011년 7월 이전 구간에 대해서는 일반적인 사진 호스팅 URL에 매칭되는 규칙 절(clause)을 필터에 포함해야 합니다.
- 일부 메타데이터는 게시물이 X에 게시된 _이후_ 시점의 메타데이터로 백필(backfill)되었습니다.

PowerTrack 쿼리를 만들 때 일반적으로 중점적으로 다루는 속성 유형은 다음과 같습니다.

- X 프로필
- 원본 또는 공유 게시물
- 게시물 언어 분류
- 지리 정보가 참조된 게시물
- 공유된 링크 미디어

이들 중 일부는 제품별로 동작이 다르며, 다른 일부는 동일하게 동작합니다. 자세한 내용은 아래를 참조하세요.

<div id="x-profiles">
  #### X 프로필
</div>

Search API는 과거 게시물을 제공할 때 \_조회 시점\_의 사용자 프로필 데이터 세트를 함께 제공합니다. 2014년의 게시물을 요청하더라도 해당 사용자의 프로필 메타데이터는 쿼리 시점의 상태를 반영합니다.

<div id="original-posts-and-retweets">
  #### 원본 게시물과 리트윗
</div>

PowerTrack `_is:retweet_` 연산자를 사용하면 리트윗을 포함하거나 제외할 수 있습니다. 이 연산자를 사용하는 경우 2009년 8월 이전 데이터에 대해서는 리트윗 매칭(또는 비매칭)을 위한 두 가지 전략이 필요합니다. 2009년 8월 이전에는 게시물 본문에서 “@RT ” 패턴과의 정확한 구문 일치로 일치 여부를 확인해야 합니다(실제로 2009년 5월부터 8월 사이의 리트윗을 필터링하는 경우 “Via @” 패턴도 포함해야 합니다). 2009년 8월 이후 기간에는 _is:retweet_ 연산자를 사용할 수 있습니다.

<div id="post-language-classifications">
  #### 게시 언어 분류
</div>

게시의 언어 분류로 필터링하는 방식은 X의 과거 제품마다 꽤 차이가 있습니다. 검색 아카이브를 구축할 때, 전체 게시물에 X 언어 분류가 소급 적용되었습니다. 따라서 lang: 연산자는 전체 게시 아카이브에서 사용할 수 있습니다.

<div id="geo-referencing-posts">
  #### 게시물 지리 참조
</div>

게시물을 지리적으로 참조하는 기본 방법은 세 가지입니다:

- **게시물 메시지의 지리적 언급.** 게시물 메시지에 포함된 지리적 언급을 기준으로 매칭하는 방법은 지역 지식에 의존하므로 가장 까다로운 편이지만, 전체 게시물 아카이브에 적용할 수 있는 옵션입니다. [여기](https://x.com/biz/statuses/28311)는 ‘golden gate’ 필터를 기반으로 샌프란시스코 지역에서 2006년에 매칭된 지리 참조 예시입니다.

- **사용자가 지오태그한 게시물.** 검색 API에서는 일부 Geo 연산자에 대해 2010년 3월부터, 다른 연산자에 대해서는 2015년 2월부터 게시물 매칭을 지원합니다:

  - 2010년 3월 6일: `has:geo`, `bounding_box:`, `point_radius:`
  - 2015년 2월 17일: `place_country:`, `place:`

- **사용자가 설정한 계정 프로필 ‘home’ 위치.** 프로필 Geo 연산자는 Historical PowerTrack과 Search API 모두에서 사용할 수 있습니다. Search API에서는 이 프로필 Geo 메타데이터가 2015년 2월부터 제공됩니다. 프로필 Geo 메타데이터가 도입되기 이전에 게시된 게시물의 경우, 정규화되지 않은 사용자 입력과 매칭하는 데 사용할 수 있는 `bio_location:` 연산자를 사용할 수 있습니다.

<div id="shared-links-and-media">
  #### 공유된 링크와 미디어
</div>

2012년 3월, 확장 URL 보강이 도입되었습니다. 그 이전에는 게시물 페이로드에 사용자가 제공한 URL만 포함되었습니다. 따라서 사용자가 단축 URL을 포함한 경우 관심 있는(확장된) URL과 매칭하기가 어려울 수 있습니다. Search API에서는 이러한 메타데이터가 2012년 3월부터 제공됩니다.

2016년 7월, 향상된 URL 보강이 도입되었습니다. 이 향상된 버전은 게시물 페이로드에 웹사이트의 HTML 제목과 설명을 포함하며, 이에 대한 매칭을 위한 연산자도 함께 제공합니다. 이러한 메타데이터는 2014년 12월부터 나타나기 시작했습니다.

2016년 9월, X는 게시물 끝에 붙는 공유 링크가 140자 게시물 길이 제한에 포함되지 않는 ‘네이티브 첨부’를 도입했습니다. 두 가지 URL 보강은 이러한 공유 링크에도 계속 적용됩니다.

관련 검색 연산자가 매칭되기 시작한 시점은 다음과 같습니다:

- 2006년 10월 26일 - `has:links`
- 2011년 7월 20일 - `has:images` 및 `has:media`
- 2011년 8월 - `url:` [확장 URL 보강](/ko/x-api/enterprise-gnip-2.0/fundamentals/data-enrichments)과 함께. 이르면 2006년 9월부터 `(url:"spotify.com" OR url:gnip OR url:microsoft OR url:google OR url:youtube)`는 twitter\_entities와 gnip 객체에 urls\[] 메타데이터가 없어도 http://x.com/Adam/statuses/16602 과 매칭됩니다. “youtube.com”은 urls\[] 메타데이터 없이도 url:youtube와 매칭되는 메시지 콘텐츠의 한 예입니다.
- 2015년 2월 10일 - 네이티브 동영상에 대한 `has:videos`. 2010/08/28부터 2015/02/10까지 이 연산자는 youtube.com, vimeo.com, vivo.com 등 일부 동영상 호스팅 사이트로의 링크가 있는 게시물과 매칭됩니다.
- 2016년 5월 1일 - [향상된 URL 보강](/ko/x-api/enterprise-gnip-2.0/fundamentals/data-enrichments)을 기반으로 한 `url_title:` 및 `url_description:`이 일반 제공(GA)됩니다. 최초의 향상된 URL 메타데이터는 2014년 12월에 나타나기 시작했습니다.

<div id="frequently-asked-questionsfaq">
  ## 자주 묻는 질문(FAQ)
</div>

<div id="general-search-post-api-questions">
  ### 일반 검색 포스트 API 관련 질문
</div>

<AccordionGroup>
  <Accordion title="The number of Posts I receive with the data endpoint doesn't match the number of Posts identified by the counts endpoint. Why is this the case?">
    counts 엔드포인트와 data 엔드포인트가 제공하는 결과에는 알려진 차이가 있습니다. counts 엔드포인트는 사전 컴플라이언스 상태(삭제된 포스트, 위치 정보 스크럽 등은 반영하지 않음)인 반면, data 엔드포인트는 제공 시점에 컴플라이언스를 준수하여 모든 컴플라이언스 이벤트를 반영하므로 결과에 차이가 발생할 수 있습니다.
  </Accordion>

  <Accordion title="I didn't receive a Post that should match my query. Why?">
    이 문제가 발생했을 수 있는 이유는 몇 가지가 있습니다. 예를 들면 다음과 같습니다.

    1. 확인하려던 게시물이 보호된 계정의 게시물인 경우
    2. 데이터 엔드포인트가 모든 컴플라이언스 이벤트를 반영하기 때문입니다(즉, 삭제된 게시물, 정제된 지오 정보 등은 응답에 포함되지 않습니다).
  </Accordion>

  <Accordion title="My query matched a Post but includes a keyword that I negated. Why is this happening?">
    이는 프리미엄 규칙과 필터링을 잘못 사용한 데에서 비롯됐을 가능성이 큽니다. 문서 [여기](/ko/x-api/enterprise-gnip-2.0/fundamentals/rules-filtering)를 검토하고, 규칙을 작성할 때 적용되는 제한 사항을 충분히 이해했는지 확인하세요.
  </Accordion>

  <Accordion title="Are there any libraries that I can use to get started using the Search Post APIs?">
    네, 다음과 같습니다:

    - [Tweepy](http://www.tweepy.org/) - 표준 검색/게시 제품을 사용하는 데 적합함(Python)
    - [X API](https://github.com/geduldig/TwitterAPI) - 표준 검색 게시 API를 사용하는 데 적합함(Python)
    - [Search Posts Python](https://github.com/xdevplatform/search-tweets-python) 및 [Search Posts Ruby](https://github.com/xdevplatform/search-tweets-ruby) - 엔터프라이즈(및 v2) 검색 게시 API에 활용할 수 있는 두 가지 우수한 도구

    저희가 직접 지원하는 모든 라이브러리는 xdevplatform GitHub 페이지에서 확인하실 수 있습니다: [https://github.com/xdevplatform](https://github.com/xdevplatform).

    [다른 서드파티 라이브러리](/ko/resources/fundamentals/authentication#oauth-1-0a-2)도 도움이 될 수 있습니다. 다만, 일부는 프리미엄 및 엔터프라이즈 제품에서 동작하지 않을 수 있으니 유의하세요.
  </Accordion>

  <Accordion title="Will I ever receive less volume of Posts than the value I set as the `maxResults` in my request to the data endpoint?">
    예. 데이터 엔드포인트는 지정한 `maxResults`에 도달하거나 30일이 지나면 페이지네이션됩니다.

    예를 들어, 특정 30일 기간에 게시물이 800개라면 전체 결과를 받기 위해 두 번 요청해야 합니다. 요청당 반환 가능한 최대 게시물 수가 500개(`maxResults`)이기 때문입니다. 또 첫 번째 달에 400개, 두 번째 달에 100개가 있는 경우에도 전체 결과를 받으려면 두 번 요청해야 합니다. 첫 번째 요청이 지정한 `maxResults`보다 적게 반환되더라도 30일이 지나면 페이지네이션이 이루어지기 때문입니다.
  </Accordion>

  <Accordion title="In what order are the matching Posts returned?">
    게시물은 최신순(내림차순)으로 반환됩니다. 예를 들어 첫 페이지 결과에는 쿼리와 일치하는 가장 최근 게시물이 표시되며, 페이지네이션은 결과의 게시 날짜가 처음 요청한 `fromDate`에 도달할 때까지 계속됩니다.
  </Accordion>

  <Accordion title="How do Edit Posts impact my usage and billing?">
    청구 목적에는 원본 게시글만 산정됩니다. 이후 수정은 무시되며 전체 활동 수에 반영되지 않습니다.

    `Enterprise`
  </Accordion>

  <Accordion title="I'm interested in learning more about the pricing of the enterprise Search Post API and in applying for this offering. How can I do this?">
    당사의 엔터프라이즈 솔루션은 예측 가능한 가격으로 귀사의 비즈니스 요구에 맞춰 커스터마이즈됩니다. 자세한 내용은 [여기](/ko/x-api/enterprise-gnip-2.0/enterprise-gnip)에서 신청해 주세요.
  </Accordion>

  <Accordion title="How do I build a rule set that matches my use case?">
    - 엔터프라이즈 Search Post API 문서는 [여기](/ko/x-api/enterprise-gnip-2.0/fundamentals/search-api#enterprise-search-apis)를 참고하세요.
    - 규칙 및 필터링에 관한 유용한 정보는 [여기](/ko/x-api/enterprise-gnip-2.0/fundamentals/rules-filtering#enterprise-operators)에서 확인할 수 있습니다.
    - 데이터 엔드포인트 사용에 관한 유용한 정보는 [여기](/ko/x-api/enterprise-gnip-2.0/fundamentals/search-api#data-endpoint)에서 확인할 수 있습니다.
    - 카운트 엔드포인트 사용에 관한 유용한 정보는 [여기](/ko/x-api/enterprise-gnip-2.0/fundamentals/search-api#counts-endpoint)에서 확인할 수 있습니다.
    - 사용 가능한 연산자 목록은 [여기](/ko/x-api/enterprise-gnip-2.0/fundamentals/search-api#available-operators)에서 확인할 수 있습니다.
  </Accordion>

  <Accordion title="I have exceeded my request caps/limits for the month, but I need to access more data - what can I do?">
    이와 관련해 도움을 받으실 수 있도록 X의 담당 어카운트 매니저에게 연락해 주시기 바랍니다.
  </Accordion>
</AccordionGroup>

<div id="error-troubleshooting-guide">
  ### 오류 문제 해결 가이드
</div>

**코드 404 - 찾을 수 없음**

1. 각 엔드포인트에 맞는 올바른 매개변수를 사용하는지 확인하세요(예: `buckets` 필드는 counts 엔드포인트에서만 사용할 수 있으며 data 엔드포인트에서는 사용할 수 없습니다).
2. `:product`, `:account_name`, `:label` 필드가 올바른지 다시 확인하세요. `:label` 필드는 GNIP 콘솔(엔터프라이즈 고객 전용)에서 확인할 수 있습니다.

<div id="api-reference">
  ## API 참고 문서
</div>

<div id="enterprise-search-apis">
  ### 엔터프라이즈 검색 API
</div>

엔터프라이즈 검색 API는 두 가지가 있습니다:

- 30일 검색 API - 최근 30일 내에 게시된 트윗을 제공합니다.
- 전체 아카이브 검색 API - 2006년 3월 첫 트윗부터 시작해 2006년까지 거슬러 올라가는 트윗을 제공합니다.

이 검색 API들은 공통 설계를 따르며, 아래 문서는 두 API 모두에 적용됩니다. 2022년 9월 29일 이후에 생성된 트윗의 트윗 객체에는 수정 이력을 나타내는 트윗 수정 메타데이터가 포함됩니다. 자세한 내용은 ["트윗 수정"](/ko/x-api/enterprise-gnip-2.0/fundamentals/edit-tweets) 기본 사항 페이지를 참고하세요.

아래는 엔터프라이즈 검색 API를 통합할 때 필요한 주요 사항입니다:

- 트윗 데이터 및 카운트 요청 방법
- 인증
- 페이지네이션
- API 요청 매개변수 및 예시 요청
- API 응답 JSON 페이로드 및 예시 응답
- HTTP 응답 코드

엔터프라이즈 API는 낮은 지연 시간, 완전한 충실도, 쿼리 기반의 트윗 아카이브 액세스를 제공합니다. 두 API의 유일한 차이는 검색 가능한 기간으로, 최근 30일 또는 2006년까지의 전체 기간입니다. 기간은 분 단위 세분화로 지정할 수 있습니다. 트윗 데이터는 쿼리와 일치하는 가장 최근 트윗부터 역순 시간순으로 제공됩니다. 트윗은 게시 후 약 30초가 지나면 검색 API에서 이용할 수 있습니다.

<div id="methods">
  #### 메서드
</div>

엔터프라이즈 검색의 기본 URI는 `https://gnip-api.x.com/search/`입니다.

| 메서드 | 설명 |
| :--- | :--- |
| [POST /search/:product/accounts/:account\_name/:label](#SearchRequests) | 지정된 PowerTrack 규칙과 일치하는 지난 30일간의 트윗을 조회합니다. |
| [POST /search/:product/accounts/:account\_name/:label/counts](#CountRequests) | 지정된 PowerTrack 규칙과 일치하는 지난 30일간의 트윗 수를 조회합니다. |

설명:

- `:product`는 요청을 보내는 검색 엔드포인트를 나타내며 `30day` 또는 `fullarchive` 중 하나입니다.
- `:account_name`은 console.gnip.com에 표시되는 계정의 (대소문자 구분) 이름입니다.
- `:label`은 console.gnip.com에 표시되는 검색 엔드포인트의 (대소문자 구분) 레이블입니다.

예를 들어, TwitterDev 계정에 'prod'(production의 약칭) 레이블이 지정된 30일 검색 제품이 있는 경우, 검색 엔드포인트는 다음과 같습니다.

- 데이터 엔드포인트: [https://gnip-api.x.com/search/30day/accounts/TwitterDev/prod.json](https://gnip-api.x.com/search/30day/accounts/TwitterDev/prod.json)
- 카운트 엔드포인트: [https://gnip-api.x.com/search/30day/accounts/TwitterDev/prod/counts.json](https://gnip-api.x.com/search/30day/accounts/TwitterDev/prod/counts.json)

엔터프라이즈 검색 API의 전체 엔드포인트는 [https://console.gnip.com](https://console.gnip.com)에서 확인할 수 있습니다.

아래에는 curl이라는 간단한 HTTP 유틸리티를 사용한 예시 요청이 여러 개 있습니다. 이 예시들은 `:product`, `:account_name`, `:label`이 포함된 URL을 사용합니다. 이 예시들을 사용하려면 URL의 값을 본인 정보로 업데이트하세요.

<div id="authentication">
  #### 인증
</div>

엔터프라이즈 검색 API에 대한 모든 요청은 [https://console.gnip.com](https://console.gnip.com)에서 계정에 로그인할 때 사용하는 유효한 이메일 주소와 비밀번호 조합으로 구성된 HTTP \_기본 인증\_을 사용해야 합니다. 각 요청에는 _Authorization_ 헤더로 자격 증명을 전달해야 합니다.

<div id="requestresponse-behavior">
  #### 요청/응답 동작
</div>

`fromDate` 및 `toDate` 매개변수를 사용하면 API가 지원하는 어느 기간이든 요청할 수 있습니다. 30-Day search API는 가장 최근 31일의 트윗을 제공합니다(‘30-Day’ API라고 부르지만, 한 달 전체 요청을 가능하게 하려면 31일이 필요하기 때문입니다). Full-Archive search API는 최초의 트윗(2006년 3월 21일)까지 거슬러 올라가는 트윗을 제공합니다. 다만 단일 응답은 지정한 'maxResults' 또는 31일 중 더 작은 값으로 제한됩니다. 일치하는 데이터 양이나 시간 범위가 지정한 maxResults 또는 31일을 초과하면, 나머지 지정 기간을 페이지네이션하기 위해 사용해야 하는 'next' 토큰이 반환됩니다.

예를 들어 Full-Archive search를 사용해 2017년 1월 1일부터 2017년 6월 30일까지 질의와 일치하는 모든 트윗을 가져오려는 경우, 요청에서 `fromDate` 및 `toDate` 매개변수로 해당 6개월 전체 기간을 지정합니다. 검색 API는 `maxResults` 매개변수(기본값은 100)에 해당하는 수의 트윗을 포함한 첫 번째 '페이지'로 응답합니다. 일반적으로 더 많은 트윗이 있으므로, API는 다음 '페이지'의 데이터를 요청할 수 있도록 하는 'next' 토큰도 함께 제공합니다. 이 과정은 API가 더 이상 'next' 토큰을 반환하지 않을 때까지 반복됩니다. 자세한 내용은 다음 섹션을 참조하세요.

<div id="pagination">
  #### 페이지네이션
</div>

데이터 요청과 카운트 요청을 모두 수행할 때는 단일 응답에 담을 수 있는 양보다 더 많은 데이터가 있을 가능성이 큽니다. 이런 경우 응답에 ‘next’ 토큰이 포함됩니다. ‘next’ 토큰은 루트 수준 JSON 속성으로 제공됩니다. ‘next’ 토큰이 제공되면 추가로 가져올 데이터가 있다는 의미이므로 API 요청을 계속 수행해야 합니다.

**참고:** ‘next’ 토큰의 동작은 데이터 요청과 카운트 요청에서 약간 다르며, 두 경우 모두 아래에 설명되어 있고 API Reference 섹션에 예시 응답이 제공됩니다.

<div id="data-pagination">
  ##### 데이터 페이지네이션
</div>

데이터 요청은 단일 응답으로 반환할 수 있는 양보다 더 많은 데이터를 생성하는 경우가 많습니다. 각 데이터 요청에는 요청당 반환할 트윗의 최대 개수를 설정하는 매개변수가 포함됩니다. `maxResults` 매개변수의 기본값은 100이며, 10~500 범위로 설정할 수 있습니다. 쿼리와 일치하는 트윗 수가 요청에 사용한 'maxResults' 값을 초과하면, 응답에는 루트 수준 JSON 속성인 'next' 토큰이 포함됩니다. 이 'next' 토큰은 다음 요청에서 해당 쿼리와 일치하는 트윗의 다음 부분(즉, 다음 '페이지')을 가져오는 데 사용됩니다. 'next' 토큰은 해당 쿼리의 마지막 '페이지'에 도달하여 더 이상 'next' 토큰이 제공되지 않을 때까지 계속 제공됩니다.

다음 '페이지'의 데이터를 요청하려면 `query`, `toDate`, `fromDate` 매개변수를 포함해(사용한 경우) 원본과 정확히 동일한 쿼리를 다시 수행하고, 이전 응답에서 받은 값을 설정한 'next' 요청 매개변수도 포함해야 합니다. 이는 GET 또는 POST 요청 모두에 사용할 수 있습니다. 단, GET 요청의 경우 'next' 매개변수는 URL 인코딩해야 합니다.

이전 쿼리에서 받은 'next' 요소를 계속 전달하여, 쿼리로 지정한 기간에 해당하는 모든 트윗을 수신할 때까지 이어갈 수 있습니다. 'next' 요소가 포함되지 않은 응답을 받으면 마지막 페이지에 도달했음을 의미하며, 지정한 쿼리와 기간에 대해 더 이상 사용할 수 있는 데이터가 없습니다.

<div id="counts-pagination">
  ##### 카운트 페이지네이션
</div>

'counts' 엔드포인트는 일별, 시간별, 또는 분 단위로 쿼리와 연관된 트윗량을 제공합니다. 'counts' API 엔드포인트는 최대 31일치 카운트 페이로드에 대해 타임스탬프가 포함된 카운트 배열을 반환합니다. 31일을 초과하는 기간의 카운트를 요청하면 'next' 토큰이 제공됩니다. 데이터용 'next' 토큰과 마찬가지로, 원래와 동일한 쿼리를 그대로 다시 보내야 하며 이전 응답에서 받은 값을 'next' 요청 매개변수로 포함해야 합니다.

31일을 초과하는 카운트를 요청하는 경우 외에도 'next' 토큰이 제공되는 또 다른 상황이 있습니다. 쿼리 볼륨이 큰 경우 카운트 생성에 시간이 오래 걸려 응답 타임아웃이 발생할 수 있습니다. 이 경우 31일 미만의 카운트만 받게 되지만 전체 카운트 페이로드를 계속 요청할 수 있도록 'next' 토큰이 제공됩니다. **_중요:_** 타임아웃 시에는 전체 "버킷"만 반환됩니다. 따라서 2.5일치 결과는 일 단위의 전체 "버킷" 2개로 반환됩니다.

<div id="additional-notes">
  ##### 추가 참고 사항
</div>

- 검색 요청에서 fromDate 또는 toDate를 사용하면 지정한 시간 범위 내의 결과만 반환됩니다. 시간 범위 내 마지막 결과 묶음에 도달하면 'next' 토큰이 제공되지 않습니다.
- 'next' 요소는 10~500 사이의 어떤 maxResults 값과도 함께 사용할 수 있습니다(기본값 100). maxResults는 각 응답에서 반환되는 트윗 수를 결정하지만, 최종적으로 모든 결과를 받는 것을 막지는 않습니다.
- 'next' 요소는 만료되지 않습니다. 동일한 'next' 쿼리를 사용한 여러 요청은 요청 시점과 관계없이 동일한 결과를 받습니다.
- 'next' 매개변수로 결과를 페이지 처리할 때 쿼리의 경계에서 중복이 발생할 수 있습니다. 애플리케이션은 이를 허용하도록 설계되어야 합니다.

<div id="data-endpoint">
  #### 데이터 엔드포인트
</div>

<div id="post-searchproductlabel">
  ##### POST /search/:product/:label
</div>

<div id="endpoint-pattern">
  ###### 엔드포인트 패턴:
</div>

이 엔드포인트는 지정된 쿼리와 기간에 대한 데이터를 반환합니다. 기간을 지정하지 않으면 시간 매개변수는 기본적으로 최근 30일로 설정됩니다. 참고: 아래 설명된 매개변수를 URL에 인코딩하면 POST 대신 GET 요청으로도 동일한 기능을 수행할 수 있습니다.

<div id="data-request-parameters">
  ##### 데이터 요청 매개변수
</div>

| Parameters | Description | Required | Sample Value |
| :--- | :--- | :--- | :--- |
| query | 최대 2,048자의 PowerTrack 규칙 1개에 해당합니다(긍정/부정 절의 개수에는 제한 없음).  <br />  <br />이 매개변수에는 모든 연산자를 포함해 PowerTrack 규칙의 모든 부분이 들어가야 하며, 규칙의 일부를 쿼리의 다른 매개변수로 분리하면 안 됩니다.  <br />  <br />**참고:** 모든 PowerTrack 연산자가 지원되는 것은 아닙니다. 지원되는 연산자는 [여기](/ko/x-api/enterprise-gnip-2.0/fundamentals/search-api#available-operators)에 나열되어 있습니다. | Yes | (snow OR cold OR blizzard) weather |
| tag | 태그는 규칙과 해당 일치 데이터를 서로 다른 논리적 그룹으로 분리하는 데 사용할 수 있습니다. 규칙 태그가 제공되면 해당 규칙 태그가 'matching\_rules' 속성에 포함됩니다.  <br />  <br />규칙별 UUID를 규칙 태그에 할당하고, 원하는 매핑은 클라이언트 측에서 관리할 것을 권장합니다. | No  | 8HYG54ZGTU |
| fromDate | 트윗이 제공될 수 있는 가장 오래된 UTC 타임스탬프입니다(전체 아카이브 검색의 경우 2006년 3월 21일까지). 타임스탬프는 분 단위 세분화 수준이며 포함형입니다(예: 12:00은 00분을 포함).  <br />  <br />_지정됨:_ toDate 없이 fromDate만 사용할 경우, now()부터 fromDate까지 과거로 거슬러 올라가며 해당 쿼리의 결과가 제공됩니다.  <br />  <br />_미지정:_ fromDate를 지정하지 않으면, API는 now() 또는 toDate(지정된 경우) 기준으로 직전 30일의 모든 결과를 제공합니다.  <br />  <br />fromDate와 toDate를 모두 사용하지 않으면, API는 요청 시점부터 과거로 거슬러 올라가며 가장 최근 30일의 모든 결과를 제공합니다. | No  | 201207220000 |
| toDate | 트윗이 제공될 수 있는 가장 최신의 UTC 타임스탬프입니다. 타임스탬프는 분 단위 세분화 수준이며 비포함형입니다(예: 11:59는 해당 시간의 59분을 포함하지 않음).  <br />  <br />_지정됨:_ fromDate 없이 toDate만 사용할 경우, toDate 이전의 가장 최근 30일치 데이터가 제공됩니다.  <br />  <br />_미지정:_ toDate를 지정하지 않으면, API는 now()부터 fromDate까지 과거로 거슬러 올라가며 해당 쿼리의 모든 결과를 제공합니다.  <br />  <br />fromDate와 toDate를 모두 사용하지 않으면, API는 요청 시점부터 과거로 거슬러 올라가며 전체 30일 인덱스의 모든 결과를 제공합니다. | No  | 201208220000 |
| maxResults | 요청이 반환할 검색 결과의 최대 개수입니다. 10에서 시스템 한도(현재 500) 사이의 숫자여야 합니다. 기본적으로 요청 응답은 100개의 결과를 반환합니다. | No  | 500 |
| next | [여기](#Pagination)에 설명된 대로 다음 '페이지' 결과를 가져오는 데 사용됩니다. 이 매개변수의 값은 API 응답에서 그대로 제공되며 수정해서는 안 됩니다. | No  | NTcxODIyMDMyODMwMjU1MTA0 |

<div id="additional-details">
  ###### 추가 세부정보
</div>

|     |     |
| :--- | :--- |
| **사용 가능한 기간** | 30일: 최근 31일  <br />전체 아카이브: 2006년 3월 21일 - 현재 |
| **쿼리 형식** | 최대 2,048자의 PowerTrack 규칙 1개와 동등함(긍정/부정 절의 개수에는 제한 없음).  <br />  <br />**참고:** 모든 PowerTrack 연산자가 지원되는 것은 아닙니다. 지원되는 연산자 목록은 [Available operators](/ko/x-api/enterprise-gnip-2.0/fundamentals/search-api#available-operators)를 참조하세요. |
| **요청 한도** | 파트너에는 분 및 초 단위 세분화 수준의 속도 제한이 적용됩니다. 분당 요청 한도는 계약에 명시된 대로 파트너마다 다릅니다. 다만, 이러한 분당 한도를 단일 버스트로 사용하는 것은 의도된 바가 아닙니다. 분당 한도와 무관하게 모든 파트너는 데이터 및/또는 카운트에 대한 모든 요청을 합산하여 초당 최대 20건으로 제한됩니다. |
| **컴플라이언스** | Full-Archive Search API를 통해 제공되는 모든 데이터는 전달 시점에 컴플라이언스를 준수합니다. |
| **실시간 가용성** | 데이터는 Twitter Platform에서 생성된 후 30초 이내에 인덱스에서 사용할 수 있습니다 |

<div id="example-data-requests-and-responses">
  ##### 예시 데이터 요청 및 응답
</div>

<div id="example-post-request">
  ###### POST 요청 예시
</div>

- POST 요청의 매개변수는 아래와 같이 JSON 형식의 본문으로 전송됩니다.
- 조회하려는 PowerTrack 규칙의 모든 구성 요소(예: 키워드, bounding\_box:와 같은 기타 연산자)는 'query' 매개변수에 포함해야 합니다.
- 규칙의 일부를 쿼리 URL의 별도 매개변수로 분리하지 마십시오.

다음은 초기 데이터 요청을 위한 POST(cURL 사용) 명령 예시입니다:

```bash
    curl -X POST -u<username> "https://gnip-api.x.com/search/:product/accounts/:account_name/:label.json" -d '{"query":"from:twitterDev","maxResults":500,"fromDate":"yyyymmddhhmm","toDate":"yyyymmddhhmm"}'
```

API 응답에 'next' 토큰이 포함된 경우, 아래는 제공된 토큰을 'next' 매개변수로 설정하여 원래 요청을 이어서 수행하는 후속 요청 예시입니다:

```bash
    curl -X POST -u<username> "https://gnip-api.x.com/search/:product/accounts/:account_name/:label.json" -d '{"query":"from:twitterDev","maxResults":500,"fromDate":"yyyymmddhhmm","toDate":"yyyymmddhhmm",
    "next":"NTcxODIyMDMyODMwMjU1MTA0"}'
```

<div id="example-get-request">
  ###### GET 요청 예시
</div>

- GET 요청의 매개변수는 표준 URL 인코딩을 사용해 URL에 인코딩됩니다.
- 조회할 PowerTrack 규칙의 모든 구성요소(예: 키워드, bounding\_box:와 같은 기타 연산자)는 'query' 매개변수에 넣어야 합니다.
- 규칙의 일부를 쿼리 URL에서 별도의 매개변수로 나누지 마세요.

다음은 초기 데이터 요청을 위한 GET(cURL 사용) 명령 예시입니다:

```bash
    curl -u<username> "http://gnip-api.x.com/search/:product/accounts/:account_name/:label.json?query=from%3Atwitterdev&maxResults=500&fromDate=yyyymmddhhmm&toDate=yyyymmddhhmm"
```

<div id="example-data-responses">
  ###### 예시 데이터 응답
</div>

2022년 9월 29일 이후에 생성된 트윗에는 편집 이력을 설명하는 트윗 편집 메타데이터가 트윗 객체에 포함됩니다. 자세한 내용은 ["Edit Tweets"](/ko/x-api/enterprise-gnip-2.0/fundamentals/edit-tweets) 기본 사항 페이지를 참고하세요.

아래는 데이터 쿼리에 대한 예시 응답입니다. 이 예시는 사용 가능한 트윗이 ‘maxResults’를 초과하여 이후 요청을 위해 'next' 토큰이 제공되는 상황을 가정합니다. 쿼리와 연결된 트윗이 'maxResults' 이하면 응답에 'next' 토큰이 포함되지 않습니다.
'next' 요소의 값은 각 쿼리마다 달라지며 불투명한 문자열로 취급해야 합니다. 'next' 요소는 응답 본문에서 다음과 같은 형태로 표시됩니다:

```json
{
    "results":
      [
            {--Tweet 1--},
            {--Tweet 2--},
            ...
            {--Tweet 500--}
      ],
    "next":"NTcxODIyMDMyODMwMjU1MTA0",
    "requestParameters":
      {
        "maxResults":500,
        "fromDate":"201101010000",
        "toDate":"201201010000"
      }
  }
```

후속 요청에 대한 응답은 다음과 같을 수 있습니다(새로운 트윗과 변경된 'next' 값에 주의하세요):

```json
{
      "results":
      [
            {--Tweet 501--},
            {--Tweet 502--},
            ...
            {--Tweet 1000--}
      ],
      "next":"R2hCDbpBFR6eLXGwiRF1cQ",
      "requestParameters":
      {
        "maxResults":500,
        "fromDate":"201101010000",
        "toDate":"201201010000"
      }
  }
```

이전 쿼리에서 받은 'next' 요소를 계속 전달하여 쿼리로 지정한 기간의 모든 트윗을 받을 때까지 요청을 이어갈 수 있습니다. 'next' 요소가 포함되지 않은 응답을 받으면 마지막 페이지에 도달했음을 의미하며, 지정한 기간 내에 추가 데이터가 없다는 뜻입니다.

<div id="counts-endpoint">
  #### 카운트 엔드포인트
</div>

<div id="searchstreamcounts">
  ##### /search/:stream/counts
</div>

<div id="endpoint-pattern">
  ###### 엔드포인트 패턴:
</div>

`/search/fullarchive/accounts/:account_name/:label/counts.json`

이 엔드포인트는 지정된 쿼리에 대한 카운트(데이터 볼륨) 데이터를 반환합니다. 기간을 지정하지 않으면 시간 매개변수는 기본적으로 최근 30일로 설정됩니다. 데이터 볼륨은 일간, 시간별(기본값), 또는 분 단위의 타임스탬프 배열로 반환됩니다.

**참고:** 아래에 설명된 매개변수를 URL에 인코딩하면 POST 대신 GET 요청으로도 동일한 기능을 수행할 수 있습니다.

<div id="counts-request-parameters">
  ##### 카운트 요청 매개변수
</div>

| Parameters | Description | Required | Sample Value |
| :--- | :--- | :--- | :--- |
| query | 최대 2,048자의 PowerTrack 규칙 1개에 해당합니다(긍정·부정 절의 개수에는 제한 없음).  <br />  <br />이 매개변수에는 모든 연산자를 포함한 PowerTrack 규칙의 모든 요소가 포함되어야 하며, 규칙의 일부를 쿼리의 다른 매개변수로 분리해서는 안 됩니다.  <br />  <br />**참고:** 모든 PowerTrack 연산자가 지원되는 것은 아닙니다. 지원되는 연산자 목록은 [Available operators](/ko/x-api/enterprise-gnip-2.0/fundamentals/search-api#available-operators)를 참조하세요. | Yes | (snow OR cold OR blizzard) weather |
| fromDate | 트윗이 제공될 수 있는 가장 오래된 UTC 타임스탬프(2006/3/21까지). 타임스탬프는 분 단위이며 포함형입니다(예: 12:00은 00분을 포함).  <br />  <br />_지정한 경우:_ toDate 없이 fromDate만 사용하면, API는 지금부터 fromDate까지 과거로 거슬러 올라가며 쿼리에 대한 카운트(데이터 볼륨)를 제공합니다. fromDate가 현재로부터 31일보다 이전이면, 요청을 페이징하기 위한 next 토큰을 받게 됩니다.  <br />  <br />_미지정:_ fromDate가 지정되지 않으면, API는 지금(now) 또는 toDate(지정된 경우) 기준으로 이전 30일의 카운트(데이터 볼륨)를 제공합니다.  <br />  <br />fromDate와 toDate를 모두 사용하지 않으면, API는 요청 시점부터 과거로 거슬러 올라가며 최근 30일의 카운트(데이터 볼륨)를 제공합니다. | No  | 201207220000 |
| toDate | 트윗이 제공될 수 있는 가장 최신 UTC 타임스탬프. 타임스탬프는 분 단위이며 비포함형입니다(예: 11:59는 해당 시의 59분을 포함하지 않음).  <br />  <br />_지정한 경우:_ fromDate 없이 toDate만 사용하면, toDate로부터 이전 30일의 최신 카운트(데이터 볼륨)를 제공합니다.  <br />  <br />_미지정:_ toDate가 지정되지 않으면, API는 쿼리에 대해 fromDate까지 과거로 거슬러 올라가며 카운트(데이터 볼륨)를 제공합니다. fromDate가 현재로부터 31일보다 이전이면, 요청을 페이징하기 위한 next 토큰을 받게 됩니다.  <br />  <br />fromDate와 toDate를 모두 사용하지 않으면, API는 요청 시점부터 과거로 거슬러 올라가며 최근 30일의 카운트(데이터 볼륨)를 제공합니다. | No  | 201208220000 |
| bucket | 카운트 데이터가 제공될 시간 단위입니다. 요청한 기간 동안 일·시·분 단위의 카운트 데이터를 반환할 수 있습니다. 기본값은 시간(hour) 단위입니다. 옵션: 'day', 'hour', 'minute' | No  | minute |
| next | [HERE](#Pagination)에 설명된 대로 다음 '페이지'의 결과를 가져오는 데 사용하는 매개변수입니다. 이 매개변수의 값은 API 응답에서 그대로 가져오며 수정해서는 안 됩니다. | No  | NTcxODIyMDMyODMwMjU1MTA0 |

<div id="additional-details">
  ###### 추가 세부정보
</div>

|     |     |
| :--- | :--- |
| **사용 가능 기간** | 30일: 최근 31일  <br />전체 아카이브: 2006년 3월 21일 - 현재 |
| **쿼리 형식** | 최대 2,048자의 PowerTrack 규칙 1개와 동일합니다.  <br />  <br />**참고:** 모든 PowerTrack 연산자가 지원되는 것은 아닙니다. 지원되는 연산자 목록은 [사용 가능한 연산자](/ko/x-api/enterprise-gnip-2.0/fundamentals/search-api#available-operators)를 참조하세요. |
| **요율 제한** | 파트너에는 분 및 초 단위로 요율 제한이 적용됩니다. 분당 요율 제한은 계약에 따라 파트너별로 다를 수 있습니다. 다만 이러한 분당 한도는 단일 버스트로 소진하도록 설계되지 않았습니다. 분당 한도와 관계없이, 모든 파트너는 데이터 및/또는 카운트 요청을 합산하여 초당 최대 20건의 요청으로 제한됩니다. |
| **카운트 정밀도** | 이 엔드포인트에서 제공되는 카운트는 발생한 트윗 수를 반영하며, 이후 컴플라이언스 이벤트(삭제, 위치 정보 정리 등)는 반영하지 않습니다. 카운트에 포함된 일부 트윗은 사용자의 컴플라이언스 조치로 인해 데이터 엔드포인트에서 제공되지 않을 수 있습니다. |

<div id="example-counts-requests-and-responses">
  ##### 예시 카운트 요청과 응답
</div>

<div id="example-post-request">
  ###### POST 요청 예시
</div>

- POST 요청의 매개변수는 아래와 같이 JSON 형식의 본문으로 전송됩니다.
- 조회하려는 PowerTrack 규칙의 모든 요소(예: 키워드, bounding\_box: 같은 기타 연산자)는 'query' 매개변수에 넣어야 합니다.
- 규칙의 일부를 쿼리 URL의 별도 매개변수로 분리하지 마십시오.

다음은 초기 카운트 요청을 수행하기 위한 POST(cURL 사용) 명령 예시입니다:

```bash
    curl -X POST -u<username> "https://gnip-api.x.com/search/:product/accounts/:account_name/:label/counts.json" -d '{"query":"TwitterDev","fromDate":"yyyymmddhhmm","toDate":"yyyymmddhhmm","bucket":"day"}'
```

API 카운트 응답에 'next' 토큰이 포함된 경우, 아래는 제공된 토큰을 'next' 매개변수로 설정하여 원래 요청을 이어서 보내는 후속 요청 예시입니다:

```bash
    curl -X POST -u<username> "https://gnip-api.x.com/search/:product/accounts/:account_name/:label/counts.json" -d '{"query":"TwitterDev","fromDate":"yyyymmddhhmm","toDate":"yyyymmddhhmm","bucket":"day",
    "next":"YUcxO87yMDMyODMwMjU1MTA0"}'
```

<div id="example-get-request">
  ###### GET 요청 예시
</div>

- GET 요청의 매개변수는 표준 URL 인코딩을 사용해 URL에 인코딩됩니다
- 조회하려는 PowerTrack 규칙의 모든 요소(예: 키워드, bounding\_box:와 같은 기타 연산자)는 'query' 매개변수에 포함해야 합니다
- 규칙의 일부를 쿼리 URL에서 별도의 매개변수로 분리하지 마십시오

다음은 초기 카운트 요청을 수행하기 위한 GET(cURL 사용) 명령 예시입니다:

```bash
    curl -u<username> "http://gnip-api.x.com/search/fullarchive/accounts/:account_name/:label/counts.json?query=TwitterDev&bucket=day&fromDate=yyyymmddhhmm&toDate=yyyymmddhhmm"
```

<div id="example-counts-responses">
  #### 예시 counts 응답
</div>

아래는 counts(데이터 볼륨) 쿼리에 대한 예시 응답입니다. 이 예시 응답에는 'next' 토큰이 포함되어 있는데, 이는 counts 요청 기간이 31일을 초과했거나 제출한 쿼리의 데이터 볼륨이 커서 부분 응답이 반환되었음을 의미합니다.

'next' 요소의 값은 쿼리마다 달라지며 불투명한 문자열로 취급해야 합니다. 응답 본문에서 'next' 요소는 다음과 같이 표시됩니다:

```json
    {
      "results": [
        { "timePeriod": "201101010000", "count": 32 },
        { "timePeriod": "201101020000", "count": 45 },
        { "timePeriod": "201101030000", "count": 57 },
        { "timePeriod": "201101040000", "count": 123 },
        { "timePeriod": "201101050000", "count": 134 },
        { "timePeriod": "201101060000", "count": 120 },
        { "timePeriod": "201101070000", "count": 43 },
        { "timePeriod": "201101080000", "count": 65 },
        { "timePeriod": "201101090000", "count": 85 },
        { "timePeriod": "201101100000", "count": 32 },
        { "timePeriod": "201101110000", "count": 23 },
        { "timePeriod": "201101120000", "count": 85 },
        { "timePeriod": "201101130000", "count": 32 },
        { "timePeriod": "201101140000", "count": 95 },
        { "timePeriod": "201101150000", "count": 109 },
        { "timePeriod": "201101160000", "count": 34 },
        { "timePeriod": "201101170000", "count": 74 },
        { "timePeriod": "201101180000", "count": 24 },
        { "timePeriod": "201101190000", "count": 90 },
        { "timePeriod": "201101200000", "count": 85 },
        { "timePeriod": "201101210000", "count": 93 },
        { "timePeriod": "201101220000", "count": 48 },
        { "timePeriod": "201101230000", "count": 37 },
        { "timePeriod": "201101240000", "count": 54 },
        { "timePeriod": "201101250000", "count": 52 },
        { "timePeriod": "201101260000", "count": 84 },
        { "timePeriod": "201101270000", "count": 120 },
        { "timePeriod": "201101280000", "count": 34 },
        { "timePeriod": "201101290000", "count": 83 },
        { "timePeriod": "201101300000", "count": 23 },
        { "timePeriod": "201101310000", "count": 12 }
       ],
      "totalCount":2027,
      "next":"NTcxODIyMDMyODMwMjU1MTA0",
      "requestParameters":
        {
          "bucket":"day",
          "fromDate":"201101010000",
          "toDate":"201201010000"
        }
    }
```

후속 요청의 응답은 다음과 같을 수 있습니다(새로운 counts 타임라인과 변경된 'next' 값에 주목):

```json
    {
      "results": [
        { "timePeriod": "201102010000", "count": 45 },
        { "timePeriod": "201102020000", "count": 76 },
         ....
        { "timePeriod": "201103030000", "count": 13 }
     ],
     "totalCount":3288,
     "next":"WE79fnakFanyMDMyODMwMjU1MTA0",
     "requestParameters":
        {
          "bucket":"day",
          "fromDate":"201101010000",
          "toDate":"201201010000"
        }
    }
```

이전 쿼리에서 받은 'next' 요소를 계속 전달하여 쿼리 기간의 모든 count를 받을 때까지 요청을 이어갈 수 있습니다. 'next' 요소가 포함되지 않은 응답을 받으면 마지막 페이지에 도달했으며 해당 기간에 추가 count가 없음을 의미합니다.

<div id="http-response-codes">
  #### HTTP 응답 코드
</div>

| 상태 | 텍스트 | 설명 |
| :--- | :--- | :--- |
| 200 | OK  | 요청이 성공했습니다. JSON 응답은 다음과 유사합니다. |
| 400 | Bad Request | 일반적으로 요청에 잘못된 JSON이 포함되어 있거나 JSON 페이로드를 전혀 보내지 않은 경우 발생합니다. |
| 401 | Unauthorized | 잘못된 자격 증명으로 인해 HTTP 인증에 실패했습니다. 요청에서 자격 증명을 올바르게 사용하는지 확인하려면 console.gnip.com에 로그인하세요. |
| 404 | Not Found | 요청이 전송된 URL에서 리소스를 찾을 수 없습니다. 잘못된 URL을 사용했을 가능성이 큽니다. |
| 422 | Unprocessable Entity | 쿼리에 잘못된 매개변수가 있어 반환됩니다. 예: 잘못된 PowerTrack 규칙 |
| 429 | Unknown Code | 앱이 연결 요청 한도를 초과했습니다. 해당 JSON 메시지는 다음과 유사합니다. |
| 500 | Internal Server Error | 서버 측 오류가 발생했습니다. 지수 백오프 패턴으로 요청을 재시도하세요. |
| 502 | Proxy Error | 서버 측 오류가 발생했습니다. 지수 백오프 패턴으로 요청을 재시도하세요. |
| 503 | Service Unavailable | 서버 측 오류가 발생했습니다. 지수 백오프 패턴으로 요청을 재시도하세요. |