---
title: Bonnes pratiques
---

import { Button } from "/snippets/fr/button.mdx";

Vos clÃ©s et jetons dâ€™API doivent Ãªtre protÃ©gÃ©s avec la plus grande attention.

Ces identifiants sont directement liÃ©s Ã  votre [application dÃ©veloppeur](/fr/resources/fundamentals/developer-apps) et aux comptes X qui vous ont autorisÃ© Ã  effectuer des requÃªtes en leur nom. Si vos clÃ©s sont compromises, des acteurs malveillants pourraient les utiliser pour envoyer des requÃªtes vers les endpoints X au nom de votre application dÃ©veloppeur ou de ses utilisateurs autorisÃ©s, ce qui pourrait vous faire atteindre des limites de dÃ©bit inattendues, Ã©puiser votre quota dâ€™accÃ¨s payant, voire entraÃ®ner la suspension de votre application dÃ©veloppeur.

Les sections suivantes prÃ©sentent des bonnes pratiques Ã  prendre en compte lors de la gestion de vos clÃ©s et jetons dâ€™API.

<div id="regenerate-api-keys-and-tokens">
  ## RÃ©gÃ©nÃ©rer des clÃ©s et des jetons API
</div>

Si vous pensez que vos clÃ©s API ont Ã©tÃ© exposÃ©es, vous devez les rÃ©gÃ©nÃ©rer en suivant ces Ã©tapesÂ :

1. AccÃ©dez Ã  la [page Â«Â Projets et applicationsÂ Â» du portail dÃ©veloppeur](https://developer.x.com/en/portal/projects-and-apps.html).
2. Cliquez sur lâ€™icÃ´ne Â«Â Keys and tokensÂ Â» (ğŸ—) Ã  cÃ´tÃ© de lâ€™application concernÃ©e.
3. Cliquez sur le bouton Â«Â RegenerateÂ Â» Ã  cÃ´tÃ© de lâ€™ensemble de clÃ©s et de jetons que vous souhaitez rÃ©gÃ©nÃ©rer.

Si vous prÃ©fÃ©rez rÃ©gÃ©nÃ©rer vos Access Tokens ou Bearer Tokens par programmation, vous pouvez le faire Ã  lâ€™aide de nos endpoints dâ€™authentification.

- Pour rÃ©gÃ©nÃ©rer vos Access Tokens, vous devez dâ€™abord invalider vos jetons via lâ€™endpoint [POST oauth/invalidate\_token](/fr/resources/fundamentals/authentication/api-reference#post-oauth2-invalidate-token), puis rÃ©gÃ©nÃ©rer vos jetons en utilisant le [flux OAuth en 3 Ã©tapes](/fr/resources/fundamentals/authentication/oauth-1-0a/obtaining-user-access-tokens).
- Pour rÃ©gÃ©nÃ©rer votre Bearer Token, vous devez dâ€™abord invalider votre jeton via lâ€™endpoint [POST oauth2/invalidate\_token](/fr/resources/fundamentals/authentication/api-reference#post-oauth2-invalidate-token), puis rÃ©gÃ©nÃ©rer votre jeton via lâ€™endpoint [POST oauth2/token](/fr/resources/fundamentals/authentication/api-reference#post-oauth2-token).

<div id="having-a-central-file-for-your-secrets">
  ## Disposer dâ€™un fichier central pour vos secrets
</div>

Avoir un fichier comme un .env ou tout autre fichier .yaml pour stocker vos secrets peut Ãªtre utile, mais veillez Ã  disposer dâ€™un .gitignore solide afin dâ€™Ã©viter de les committer par inadvertance dans un dÃ©pÃ´t Git.Â 

<div id="environment-variables">
  ## Variables d'environnement
</div>

Ã‰crire du code qui utilise des variables d'environnement peut Ãªtre utile.

Voici un exemple en PythonÂ :

```python
import os

consumer_key = os.environ.get("CONSUMER_KEY")

consumer_secret = os.environ.get("CONSUMER_SECRET")
```

Dans votre terminal, vous pouvez saisir quelque chose commeÂ :

```bash
export CONSUMER_KEY='xxxxxxxxxxxxxxxxxxx'
export CONSUMER_SECRET='xxxxxxxxxxxxxxxxxxxxxxx'
```

<div id="source-code-and-version-control">
  ## Code source et gestion de versions
</div>

Les erreurs de sÃ©curitÃ© les plus courantes commises par les dÃ©veloppeurs consistent Ã  laisser des clÃ©s et des jetons dâ€™API dans le code source, puis Ã  les valider dans des systÃ¨mes de gestion de versions accessibles comme GitHub et Bitbucket. Beaucoup de ces dÃ©pÃ´ts de code sont publics. Cette erreur est si frÃ©quente dans les dÃ©pÃ´ts publics quâ€™il existe des bots trÃ¨s rentables qui collectent des clÃ©s dâ€™API.

- Utilisez des variables dâ€™environnement cÃ´tÃ© serveur. En stockant les clÃ©s dâ€™API dans des variables dâ€™environnement, vous les gardez hors de votre code et de votre gestion de versions. Cela vous permet aussi dâ€™utiliser facilement des clÃ©s diffÃ©rentes selon les environnements.
- Utilisez un fichier de configuration exclu du contrÃ´le de source. Ajoutez le nom du fichier Ã  votre fichier [.gitignore](https://git-scm.com/docs/gitignore) pour empÃªcher que le fichier ne soit suivi par la gestion de versions.
- Si vous retirez les clÃ©s dâ€™API de votre code aprÃ¨s avoir utilisÃ© la gestion de versions, il est probable quâ€™elles restent accessibles via les versions prÃ©cÃ©dentes de votre base de code. RÃ©gÃ©nÃ©rez vos clÃ©s dâ€™API, comme dÃ©crit dans la section suivante.

<div id="databases">
  ## Bases de donnÃ©es
</div>

Si vous devez stocker vos jetons dâ€™accÃ¨s dans une base de donnÃ©es, gardez Ã  lâ€™esprit ce qui suit :

- Restreignez lâ€™accÃ¨s Ã  la base de donnÃ©es de faÃ§on Ã  ce que les jetons dâ€™accÃ¨s ne soient lisibles que par leur propriÃ©taire.
- Limitez les privilÃ¨ges de modification/Ã©criture sur la table contenant les jetons dâ€™accÃ¨s â€” cela devrait Ãªtre automatisÃ© via le systÃ¨me de gestion des clÃ©s.
- Chiffrez les jetons dâ€™accÃ¨s avant de les stocker dans tout type de stockage de donnÃ©es.

<div id="password-management-tools">
  ## Outils de gestion des mots de passe
</div>

Les outils de gestion des mots de passe tels que 1Password ou LastPass peuvent aider Ã  conserver vos clÃ©s et jetons en lieu sÃ»r. Il peut Ãªtre prÃ©fÃ©rable dâ€™Ã©viter de les partager dans un gestionnaire de mots de passe dâ€™Ã©quipe partagÃ©.

<div id="web-storage-cookies">
  ## Stockage web et cookies
</div>

Il existe deux types de stockage web : LocalStorage et SessionStorage. Ils ont Ã©tÃ© conÃ§us comme une amÃ©lioration par rapport aux cookies, car leur capacitÃ© de stockage est bien supÃ©rieure Ã  celle des cookies. Cependant, chaque option prÃ©sente des avantages et des inconvÃ©nients diffÃ©rents.
Â 

**Stockage web : LocalStorage**

Tout ce qui est stockÃ© dans le stockage web local est persistant. Cela signifie que les donnÃ©es restent prÃ©sentes jusquâ€™Ã  leur suppression explicite. Selon les besoins de votre projet, vous pouvez y voir un avantage. Toutefois, soyez prudent avec LocalStorage, car toute modification ou tout ajout de donnÃ©es sera disponible lors de toutes les visites ultÃ©rieures de la page concernÃ©e. Nous ne recommandons gÃ©nÃ©ralement pas dâ€™utiliser LocalStorage, sauf quelques exceptions. Si vous dÃ©cidez dâ€™y recourir, sachez quâ€™il applique la politique de mÃªme origine, ce qui signifie que toutes les donnÃ©es qui y sont stockÃ©es ne seront accessibles quâ€™Ã  partir de la mÃªme origine. Un bÃ©nÃ©fice de performance supplÃ©mentaire est la diminution du trafic client-serveur, puisque les donnÃ©es nâ€™ont pas Ã  Ãªtre renvoyÃ©es au serveur Ã  chaque requÃªte HTTP.
Â 

**Stockage web : SessionStorage**

SessionStorage est similaire Ã  LocalStorage, mais la diffÃ©rence clÃ© est que SessionStorage nâ€™est pas persistant. Une fois la fenÃªtre (ou lâ€™onglet, selon le navigateur) utilisÃ©e pour Ã©crire dans SessionStorage fermÃ©e, les donnÃ©es sont perdues. Cela est utile pour restreindre lâ€™accÃ¨s en lecture Ã  votre jeton au sein dâ€™une session utilisateur. Dâ€™un point de vue sÃ©curitÃ©, SessionStorage est gÃ©nÃ©ralement prÃ©fÃ©rable Ã  LocalStorage. Comme pour LocalStorage, la prise en charge de la politique de mÃªme origine et la rÃ©duction du trafic client-serveur sâ€™appliquent aussi Ã  SessionStorage.
Â 

**Cookies**

Les cookies sont le moyen traditionnel de stocker des donnÃ©es de session. Vous pouvez dÃ©finir une date dâ€™expiration pour chaque cookie, ce qui facilite la rÃ©vocation et la restriction dâ€™accÃ¨s. Cependant, le trafic client-serveur augmente avec les cookies, puisque les donnÃ©es sont renvoyÃ©es au serveur Ã  chaque requÃªte HTTP. Si vous choisissez dâ€™utiliser des cookies, vous devez vous protÃ©ger contre le dÃ©tournement de session. Par dÃ©faut, les cookies sont envoyÃ©s en clair sur HTTP, ce qui rend leur contenu vulnÃ©rable Ã  lâ€™interception de paquets et/ou aux attaques de type Â« homme du milieu Â», oÃ¹ des attaquants peuvent modifier votre trafic. Vous devez toujours imposer HTTPS pour protÃ©ger vos donnÃ©es en transit. Cela assure la confidentialitÃ©, lâ€™intÃ©gritÃ© (des donnÃ©es) et lâ€™authentification. Toutefois, si votre application ou votre site est accessible Ã  la fois via HTTP et HTTPS, vous voudrez Ã©galement utiliser lâ€™attribut Â« Secure Â» sur le cookie. Cela empÃªchera des attaquants dâ€™envoyer Ã  un utilisateur des liens vers la version HTTP de votre site et dâ€™Ã©couter la requÃªte HTTP qui en rÃ©sulterait.

Une autre mesure secondaire contre le dÃ©tournement de session lors de lâ€™utilisation de cookies consiste Ã  revÃ©rifier lâ€™identitÃ© de lâ€™utilisateur avant toute action Ã  fort impact. Un autre attribut Ã  envisager pour amÃ©liorer la sÃ©curitÃ© de vos cookies est Â« HttpOnly Â». Cet attribut indique au navigateur que le cookie en question ne doit Ãªtre accessible que par le serveur spÃ©cifiÃ©. Toute tentative dâ€™accÃ¨s par des scripts cÃ´tÃ© client sera interdite, ce qui aide Ã  se protÃ©ger contre la plupart des attaques de type cross-site scripting (XSS).