---
title: Identifiants X
icon: id-card-clip
---

Chaque objet au sein de X — un Tweet, un message privé, un utilisateur, une liste, etc. — possède un identifiant unique.

Au tout début de la plateforme, ces identifiants étaient des nombres suffisamment petits pour être générés séquentiellement. Avec le temps, pour accompagner la croissance, les identifiants sont passés de 32 bits à 64 bits. Aujourd’hui, les identifiants X sont des entiers non signés de 64 bits, basés sur le temps plutôt que séquentiels. L’identifiant complet est composé d’un horodatage, d’un numéro de worker et d’un numéro de séquence. X a développé un service interne appelé « Snowflake » afin de générer ces identifiants de manière cohérente ([en savoir plus sur le blog X](https://blog.x.com/engineering/en_us/a/2010/announcing-snowflake.html)).

Des nombres aussi grands que 64 bits peuvent poser problème avec les langages de programmation qui représentent les entiers sur moins de 64 bits. Par exemple, en JavaScript, les entiers sont limités à 53 bits. Pour contourner ce problème, dans les conceptions initiales de l’API X (v1/1.1), les valeurs d’identifiant étaient renvoyées sous deux formats : en entiers et en chaînes.

```json
{"id": 10765432100123456789, "id_str": "10765432100123456789"}
```

Si vous exécutez la commande `(10765432100123456789).toString()` dans la console JavaScript d’un navigateur, le résultat sera `"10765432100123458000"` — l’entier 64 bits perd en précision à cause de la conversion (c’est parfois appelé « munging » — une modification destructive d’une donnée).

Dans les API X jusqu’à la version 1.1, vous devez toujours utiliser la représentation sous forme de chaîne du nombre pour éviter toute perte de précision.

Dans les versions plus récentes de l’API, toutes les grandes valeurs entières sont par défaut représentées sous forme de chaînes.