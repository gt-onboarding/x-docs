---
title: ページング
sidebarTitle: ページング
---

<div id="recent-search-pagination">
  ### 最近検索のページネーション
</div>

<div id="introduction">
  #### イントロダクション
</div>

検索クエリは、単一の API レスポンスで返せる件数より多くの投稿に一致するのが一般的です。その場合、データは一連の「ページ」に分割されて返されます。ページネーションとは、データセット全体を取得するために、すべてのページを順番に要求する方法を指します。

以下は、最近の検索におけるページネーションの基本事項です。

- 最近の検索エンドポイントは、クエリに対して少なくとも 1 ページで応答し、追加のページがある場合は JSON レスポンスに next\_token を含めます。一致する投稿を取得するため、このプロセスはレスポンスからトークンが返されなくなるまで繰り返せます。

- next\_token に有効期限はありません。同じ next\_token の値を使用した複数のリクエストは、実行のタイミングに関わらず同一の結果を返します。

- 投稿は UTC タイムゾーンで新しい順（逆時系列）に返されます。これは個々のページ内だけでなく、複数ページにまたがっても同様です。
  - 最初のレスポンスの先頭の投稿は、クエリに一致する最も新しい投稿です。
  - 最後のレスポンスの末尾の投稿は、クエリに一致する最も古い投稿です。

- max\_results リクエストパラメータで、レスポンスごとに返される投稿数を設定できます。デフォルトは 10 件、最大は 100 件です。

- すべてのページネーション実装では、レスポンスのペイロードから next\_token を取り出し、それを「次のページ」の検索リクエストに含める必要があります。これらの「次のページ」リクエストの構築方法の詳細は以下を参照してください。
   

最近の検索エンドポイントは、次の 2 つの基本的な利用パターンをサポートするよう設計されています。

- **履歴データの取得** - 関心のある期間から一致する投稿を取得します。これは通常、履歴調査を目的とした一度きりのリクエストです。検索リクエストは start\_time と end\_time のリクエストパラメータに基づいて行えます。最近の検索エンドポイントは、クエリに一致する最も新しい投稿から開始し、逆時系列で投稿を返します。

- **ポーリング** - 最後に受け取った投稿以降に投稿された一致する投稿を取得します。これらのユースケースはしばしばニアリアルタイムで、新しい関心投稿を「リッスン」するために頻繁にリクエストを行うのが特徴です。最近の検索エンドポイントは、このポーリングパターンをサポートするため since\_id リクエストパラメータを提供します。投稿 ID による範囲指定に役立つ until\_id リクエストパラメータも利用可能です。
   

次に、履歴モードについて説明します。これは最近の検索エンドポイントのデフォルトモードであり、ページネーションの基本を示します。続いて、ポーリングのユースケースの例を説明します。ポーリングでページネーションが発生する場合は、検索リクエストを管理するための追加のステップが必要です。
 

<div id="retrieving-historical-data">
  #### 過去データの取得
</div>

このセクションでは、関心のある期間（現在は直近7日間に限定）から、`start_time` と `end_time` リクエストパラメータを使用して投稿を取得する方法を説明します。過去データのリクエストは、通常、調査や分析を目的とした一度限りのリクエストです。 

期間を指定してデータを取得するのは、Recent Search エンドポイントのデフォルト動作です。検索リクエストで `start_time`、`end_time`、または `since_id` が指定されていない場合、`end_time` は「現在」（実際にはクエリ時刻の30秒前）、`start_time` は7日前がデフォルトになります。

エンドポイントは、最新の投稿から始まる逆時系列で、最初の「ページ」の投稿を返します。レスポンスの JSON ペイロードには、追加のページがある場合は `next_token` も含まれます。ページ数に関係なく一致する投稿をすべて収集するには、`next_token` が返されなくなるまでリクエストを繰り返します。 

たとえば、過去1週間にキーワード snow を含む投稿に対する初回リクエストは次のとおりです:

https://api.x.com/2/tweets/search/recent?query=snow

レスポンスには、最新の10件の投稿に加えて、JSON レスポンス内に次の「meta」属性が含まれます:

```
"meta": {
        "newest_id": "1204860593741553664",
        "oldest_id": "1204860580630278147",
        "next_token": "b26v89c19zqg8o3fobd8v73egzbdt3qao235oql",
        "result_count": 10
    }
```

次の10件の投稿を取得するには、この `next_token` を元のリクエストに追加します。リクエストは次のようになります:

https://api.x.com/2/tweets/search/recent?query=snow\&next\_token=b26v89c19zqg8o3fobd8v73egzbdt3qao235oql

`next_token` を確認して後続のリクエストに含める処理は、すべて（または所定の件数の）投稿が収集されるか、指定回数のリクエストを行うまで繰り返せます。データの完全性（クエリに一致するすべての投稿を収集すること）が重要なユースケースでは、「request.next\_token が null になるまで繰り返す」という単純な設計で十分です。 
 

<div id="polling-and-listening-use-cases">
  #### ポーリングおよびリスニングのユースケース
</div>

このセクションでは、recent search エンドポイントに `since_id` リクエストパラメータを付与してポーリングし、最新の投稿を取得する方法を概説します。 

ポーリングのユースケースでは、「関心のある新しい投稿はあるか？」というクエリを継続的かつ高頻度で行います。時間ベースの履歴ユースケースとは異なり、ポーリングでは通常、リクエストは投稿 ID に基づきます。

ポーリングの中心となる考え方は、すべての新しい投稿には [unique ID](/ja/resources/fundamentals/x-ids) があり、X プラットフォームから一般的に昇順で「発行」されるという点です。ある投稿の ID が別の投稿より小さい場合、それは先に投稿されたことを意味します。

recent search エンドポイントは、投稿 ID による投稿アーカイブのナビゲーションをサポートします。エンドポイントからのレスポンスには、`oldest_id` と `newest_id` の投稿 ID が含まれます。ポーリングモードでは、これまでに受け取った最大／最新の ID を `since_id` に設定してリクエストを行います。 

例えば、雪に関する新しい投稿のクエリを 5 分ごとに行い、直近で受け取った投稿の投稿 ID が 10000 だったとします。ポーリングのタイミングで、リクエストは次のようになります。

https://api.x.com/2/tweets/search/recent?query=snow\&since\_id=10000

次に、前回のリクエスト以降に 7 件の投稿が行われたとします。これらはすべて 1 つのデータ「ページ」に収まるため、`next_token` はありません。レスポンスには、最新（newest）の投稿の投稿 ID が返されます:

```
"meta": {
        "newest_id": "12000",
        "oldest_id": "10005",
        "result_count": 7
    }
```

次のポーリングクエリを行うには、この `newest_id` の値を使用して次の `since_id` パラメータを設定します:

`https://api.x.com/2/tweets/search/recent?query=snow&since_id=12000`

より多くのデータが利用可能で `next_token` が提供される場合、必要なのは最初のページの結果に含まれる `newest_id` の値のみです。各データページには `newest_id` と `oldest_id` の値が含まれますが、次の定期的なポーリングリクエストに必要なのは最初のページで提供された値だけです。したがって、ポーリング設計を実装する場合や ID 範囲で投稿を検索する場合は、ページネーションのロジックがやや複雑になります。 

ここで、さらに 18 件の一致する投稿があるとします。エンドポイントは、この 5 分間の期間に対する最初のレスポンスとして、フルのデータページと、次のページを取得するための `next_token` を返します。また、5 分後の次のポーリング間隔に必要な最新の投稿 ID も含みます。  

```
"meta": {
        "newest_id": "13800",
        "oldest_id": "12500",
        "next_token": "fnsih9chihsnkjbvkjbsc",
        "result_count": 10
    }
```

この 5 分間の期間の一致データをすべて収集するには、前回のリクエストと同じ `since_id` の値に加えて、次のリクエストで `next_token` を渡します。

https://api.x.com/2/tweets/search/recent?query=snow\&since\_id=12000\&next\_token=fnsih9chihsnkjbvkjbsc

```
"meta": {
        "newest_id": "12300",
        "oldest_id": "12010",
        "result_count": 8
    }
```

この 2 つ目のレスポンスは残りの 8 件の投稿を返し、`next_token` はありません。ここで、`newest_id` の値（12300）を更新せず、次の `since_id` リクエストは最初のレスポンスの `newest_id` の値に基づかせることに注意してください:

https://api.x.com/2/tweets/search/recent?query=snow\&since\_id=13800