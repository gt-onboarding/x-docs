---
title: 切断時の対処
sidebarTitle: 切断時の対処
---

<div id="what-is-a-disconnection">
  ### 切断とは何ですか？
</div>

ストリーミング API への接続とは、非常に長寿命の HTTPS リクエストを発行し、レスポンスを逐次的に解析し続けることを指します。フィルタードストリームのエンドポイントに接続する場合は、HTTPS リクエストを送信し、実用的な範囲でできるだけ長く結果のストリームを読み取り続けてください。サーバー側のエラー、クライアント側の過度な遅延、ネットワークの問題、定期的なサーバーメンテナンス、または重複ログインがない限り、当社サーバーは接続を無期限に維持します。ストリーミングエンドポイントへの接続では切断が発生し得ることを前提にすべきであり、再接続ロジックを組み込んでください。
 

<div id="why-a-streaming-connection-might-be-disconnected">
  #### ストリーミング接続が切断される可能性がある理由
</div>

ストリームが切断される理由はいくつかあります。原因を把握するために、ストリームから返されるエラーメッセージを確認してください。切断の主な原因は次のとおりです。

- 認証エラー（誤ったトークンの使用、または誤った認証方式の使用など）。
- X 側でストリーミングサーバーが再起動された場合。これは通常、コードのデプロイに関連しており、想定の上で設計しておく必要があります。
- クライアントがストリームで配信される投稿量に追いつけていない、またはデータの読み取りが遅すぎる場合。すべてのストリーミング接続にはクライアントへの送信待ちメッセージのキューがあり、このキューが時間経過とともに大きくなりすぎると接続は閉じられます。
- アカウントが日次／月次の投稿上限を超過した場合。
- 冗長なアクティブ接続が多すぎる場合。
- クライアントが突然データの読み取りを停止した場合。ストリームから読み取られる投稿のレートが急に低下すると、接続は閉じられます。
- サーバーとクライアント間のネットワーク問題の可能性。
- 一時的なサーバー側の問題、計画メンテナンスや更新。（[ステータスページ](https://api.twitterstat.us/)を確認してください）
   

<div id="common-disconnection-errors-include">
  #### 一般的な切断エラーの例：
</div>

```{
	"errors": [{
		"title": "operational-disconnect",
		"disconnect_type": "UpstreamOperationalDisconnect",
		"detail": "運用上の理由により、このストリームは上流側で切断されました。",
		"type": "https://api.x.com/2/problems/operational-disconnect"
	}]
}
```

```
{
	"title": "ConnectionException",
	"detail": "このストリームは現在、許可されている最大接続数に達しています。",
	"connection_issue": "TooManyConnections",
	"type": "https://api.x.com/2/problems/streaming-connection"
}
```

<div id="anticipating-disconnects-and-reconnecting">
  #### 切断の想定と再接続
</div>

投稿をストリーミングする際は、切断が発生し得ることを踏まえつつ、可能な限り長時間の接続維持を目指してください。エンドポイントは20秒ごとにキープアライブのハートビート（改行文字として届きます）を送信します。この信号を用いて切断の兆候を検知してください。

1. 新規コンテンツとハートビートの受信が停止したことをコードで検知する必要があります。
2. その場合は、再接続ロジックを起動してください。クライアントや言語によっては読み取りタイムアウトを指定でき、20秒に設定できます。
3. サービスはこれらの切断を検知し、可能な限り速やかに再接続する必要があります。

確立済みの接続が途切れたら、直ちに再接続を試みてください。再接続に失敗した場合は、発生したエラーの種類に応じて再試行間隔を調整してください。

- TCP/IP レベルのネットワークエラーに対しては線形にバックオフします。これらの問題は一般的に一時的で、すぐに解消される傾向があります。試行ごとに再接続の遅延を250msずつ増やし、最大16秒までとします。
- 再接続が適切な HTTP エラーに対しては指数的にバックオフします。最初は5秒待機し、試行のたびに倍にして最大320秒までとします。
- HTTP 429（Rate limit exceeded）に対しては指数的にバックオフします。まず1分待機し、試行のたびに倍にします。HTTP 429 を受信するたびに、アカウントのレート制限が解除されるまでの待機時間が増加する点に注意してください。
   

<div id="recovering-lost-data">
  #### 失われたデータの復旧
</div>

切断が発生した場合、取りこぼした可能性のあるデータを漏れなく受け取るためのいくつかの戦略があります。取りこぼしデータを回収するために実施できる主要な手順は、[データの復旧](/ja/x-api/posts/filtered-stream/integrate/recovery-and-redundancy-features)に関するインテグレーションガイドにまとめています。 
 

<div id="rate-limits-and-usage">
  #### レート制限と利用状況
</div>

接続制限を確認するには、レスポンスに 3 つのヘッダーが返されます。これは、ルールエンドポイントを何回使用できるか、またストリーミングエンドポイントで許可される再接続試行回数を把握するのに有用です。

- x-rate-limit-limit は、15 分間のウィンドウ内でクライアントが実行できる割り当てリクエスト数を示します。

- x-rate-limit-remaining は、15 分間のウィンドウ内でこれまでに行われたリクエスト数を示します。

- x-rate-limit-reset は、15 分間のウィンドウが再開し、x-rate-limit-remaining が 0 にリセットされる時刻を示す UNIX タイムスタンプです。

Filtered Stream のエンドポイントは現在、利用状況データを報告しません。配信された投稿数を確認するには、必要に応じて消費量を測定・一時停止できるよう、コードでメータリングロジックを実装してください。

ストリームのクライアント側をホストするコードは、受信した投稿を先入れ先出し（FIFO）キューまたは同様のメモリ構造に単純に挿入します。別のプロセス／スレッドがそのキューから投稿を取り出して解析し、保存用にコンテンツを準備します。この設計により、受信する投稿量が大きく変動した場合でも効率的にスケールできるサービスを実装できます。概念的には、HTTP 経由で無限に長いファイルをダウンロードしていると捉えることができます。

<div id="reconnection-best-practices">
  #### 再接続のベストプラクティス
</div>

**バックオフ戦略をテストする**

バックオフ実装をテストする良い方法は、不正な認可情報を使用して再接続の試行を観察することです。適切な実装であれば、429 応答は発生しません。

**複数回の再接続に対してアラートを出す**

クライアントが再接続間隔の上限しきい値に達した場合、接続に影響している問題をトリアージできるよう、通知を送信する必要があります。

**DNS の変更に対応する**

クライアントプロセスが DNS の Time To Live（TTL）を順守することを確認してください。一部のスタックは、プロセスの存続期間中に解決済みアドレスをキャッシュし、規定の TTL 内での DNS 変更を反映しません。このような積極的なキャッシュは、X が IP アドレス間で負荷を移動する際に、クライアント側でサービス中断を引き起こします。

**User Agent**

User-Agent の HTTP ヘッダーにクライアントのバージョンを含めてください。これは X 側での問題診断において重要です。環境の制約で User-Agent フィールドを設定できない場合は、x-user-agent ヘッダーを設定してください。