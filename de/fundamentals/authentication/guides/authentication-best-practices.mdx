---
title: Bew√§hrte Verfahren
---

import { Button } from "/snippets/de/button.mdx";

Ihre API-Schl√ºssel und -Tokens sollten √§u√üerst sorgf√§ltig gesch√ºtzt werden.¬†

Diese Anmeldedaten sind direkt mit Ihrer [Developer-App](/de/resources/fundamentals/developer-apps) und den X-Konten verkn√ºpft, die Ihnen die Berechtigung erteilt haben, in ihrem Namen Anfragen zu stellen. Wenn Ihre Schl√ºssel kompromittiert werden, k√∂nnten sie von b√∂swilligen Akteuren genutzt werden, um im Namen Ihrer Developer-App oder ihrer autorisierten Nutzer Anfragen an X-Endpunkte zu stellen. Das k√∂nnte dazu f√ºhren, dass Sie unerwartete Ratenlimits erreichen, Ihr bezahltes Zugriffskontingent aufbrauchen oder dass Ihre Developer-App sogar suspendiert wird.

Die folgenden Abschnitte enthalten Best Practices, die Sie beim Verwalten Ihrer API-Schl√ºssel und -Tokens ber√ºcksichtigen sollten.

<div id="regenerate-api-keys-and-tokens">
  ## API-Schl√ºssel und -Tokens neu generieren
</div>

Falls Sie vermuten, dass Ihre API-Schl√ºssel offengelegt wurden, sollten Sie sie wie folgt neu generieren:

1. Navigieren Sie zur Seite [‚ÄûProjekte und Apps‚Äú im Developer-Portal](https://developer.x.com/en/portal/projects-and-apps.html).
2. Klicken Sie auf das Symbol ‚ÄûKeys and tokens‚Äú (üóù) neben der betreffenden App.
3. Klicken Sie auf die Schaltfl√§che ‚ÄûRegenerate‚Äú neben dem Satz von Schl√ºsseln und Tokens, den Sie neu generieren m√∂chten.

Wenn Sie Ihre Access Tokens oder Bearer Tokens programmgesteuert neu generieren m√∂chten, k√∂nnen Sie dies √ºber unsere Authentifizierungsendpunkte tun.

- Wenn Sie Ihre Access Tokens neu generieren m√∂chten, m√ºssen Sie Ihre Tokens mit dem Endpoint [POST oauth/invalidate\_token](/de/resources/fundamentals/authentication/api-reference#post-oauth2-invalidate-token) ung√ºltig machen und anschlie√üend Ihre Tokens √ºber den [3-legged OAuth-Flow](/de/resources/fundamentals/authentication/oauth-1-0a/obtaining-user-access-tokens) neu generieren.
- Wenn Sie Ihr Bearer Token neu generieren m√∂chten, m√ºssen Sie es mit dem Endpoint [POST oauth2/invalidate\_token](/de/resources/fundamentals/authentication/api-reference#post-oauth2-invalidate-token) ung√ºltig machen und anschlie√üend √ºber den Endpoint [POST oauth2/token](/de/resources/fundamentals/authentication/api-reference#post-oauth2-token) neu generieren.

<div id="having-a-central-file-for-your-secrets">
  ## Eine zentrale Datei f√ºr Ihre Secrets verwenden
</div>

Eine Datei wie eine .env-Datei oder eine andere .yaml-Datei, die Ihre Secrets enth√§lt, kann hilfreich sein. Achten Sie jedoch darauf, eine aussagekr√§ftige .gitignore-Datei zu verwenden, die verhindert, dass Sie diese versehentlich in ein Git-Repository einchecken.¬†

<div id="environment-variables">
  ## Umgebungsvariablen
</div>

Es kann hilfreich sein, Code zu schreiben, der Umgebungsvariablen verwendet.

Ein Beispiel in Python:

```python
import os

consumer_key = os.environ.get("CONSUMER_KEY")

consumer_secret = os.environ.get("CONSUMER_SECRET")
```

Im Terminal w√ºrden Sie dazu etwa Folgendes ausf√ºhren:

```bash
export CONSUMER_KEY='xxxxxxxxxxxxxxxxxxx'
export CONSUMER_SECRET='xxxxxxxxxxxxxxxxxxxxxxx'
```

<div id="source-code-and-version-control">
  ## Quellcode und Versionskontrolle
</div>

Zu den h√§ufigsten Sicherheitsfehlern von Entwicklern z√§hlt, API-Schl√ºssel und Tokens im Quellcode in zug√§nglichen Versionskontrollsystemen wie GitHub und Bitbucket zu committen. Viele dieser Code-Repositories sind √∂ffentlich zug√§nglich. Dieser Fehler kommt in √∂ffentlichen Code-Repositories so h√§ufig vor, dass es lukrative Bots gibt, die nach API-Schl√ºsseln suchen.

- Verwenden Sie Umgebungsvariablen auf dem Server. Indem Sie API-Schl√ºssel in Umgebungsvariablen speichern, halten Sie sie aus Ihrem Code und der Versionskontrolle heraus. Au√üerdem k√∂nnen Sie so unkompliziert unterschiedliche Schl√ºssel f√ºr verschiedene Umgebungen nutzen.
- Verwenden Sie eine Konfigurationsdatei, die von der Versionskontrolle ausgeschlossen ist. F√ºgen Sie den Dateinamen Ihrer [.gitignore](https://git-scm.com/docs/gitignore)-Datei hinzu, damit die Datei nicht vom Versionskontrollsystem erfasst wird.
- Wenn Sie API-Schl√ºssel aus Ihrem Code entfernen, nachdem Sie bereits Versionskontrolle verwendet haben, sind diese Schl√ºssel wahrscheinlich weiterhin zug√§nglich, indem man auf fr√ºhere Versionen Ihres Codebestands zugreift. Generieren Sie Ihre API-Schl√ºssel neu, wie im n√§chsten Abschnitt beschrieben.

<div id="databases">
  ## Datenbanken
</div>

Wenn Sie Zugriffstokens in einer Datenbank speichern m√ºssen, beachten Sie bitte Folgendes:

- Beschr√§nken Sie den Datenbankzugriff so, dass die Zugriffstokens nur vom Inhaber des jeweiligen Tokens gelesen werden k√∂nnen.
- Beschr√§nken Sie die Bearbeitungs- und Schreibrechte f√ºr die Tabelle mit Zugriffstokens ‚Äì dies sollte durch das Schl√ºsselverwaltungssystem automatisiert erfolgen.
- Verschl√ºsseln Sie Zugriffstokens, bevor Sie sie in beliebigen Datenspeichern ablegen.

<div id="password-management-tools">
  ## Tools zur Passwortverwaltung
</div>

Tools zur Passwortverwaltung wie 1Password oder LastPass k√∂nnen hilfreich sein, um Ihre Keys und Tokens sicher aufzubewahren. Sie sollten vermeiden, diese in einem gemeinsam genutzten Team-Passwortmanager zu teilen.

<div id="web-storage-cookies">
  ## Webspeicher & Cookies
</div>

Es gibt zwei Arten von Webspeicher: LocalStorage und SessionStorage. Diese wurden als Verbesserungen gegen√ºber Cookies entwickelt, da die Speicherkapazit√§t f√ºr Webspeicher deutlich h√∂her ist als f√ºr Cookies. Allerdings haben diese Speicheroptionen jeweils unterschiedliche Vor- und Nachteile.
¬†

**Webspeicher: LocalStorage**

Alles, was im lokalen Webspeicher gespeichert wird, ist persistent. Das bedeutet, dass die Daten bestehen bleiben, bis sie ausdr√ºcklich gel√∂scht werden. Je nach Anforderungen Ihres Projekts kann das positiv sein. Sie sollten den Einsatz von LocalStorage jedoch sorgf√§ltig abw√§gen, da s√§mtliche √Ñnderungen/Erg√§nzungen an Daten bei allen zuk√ºnftigen Besuchen der betreffenden Webseite verf√ºgbar sind. Wir empfehlen die Verwendung von LocalStorage in der Regel nicht, auch wenn es wenige Ausnahmen geben kann. Wenn Sie sich f√ºr LocalStorage entscheiden, ist es gut zu wissen, dass es die Same-Origin-Policy unterst√ºtzt, sodass alle hier gespeicherten Daten nur √ºber denselben Ursprung verf√ºgbar sind. Ein zus√§tzlicher Performance-Vorteil von LocalStorage ist der geringere Client-Server-Verkehr, da die Daten nicht bei jeder HTTP-Anfrage an den Server gesendet werden m√ºssen.
¬†

**Webspeicher: SessionStorage**

SessionStorage √§hnelt LocalStorage, aber der entscheidende Unterschied ist, dass SessionStorage nicht persistent ist. Sobald das Fenster (oder der Tab, je nach verwendetem Browser), mit dem in SessionStorage geschrieben wurde, geschlossen wird, gehen die Daten verloren. Das ist n√ºtzlich, um den Lesezugriff auf Ihr Token innerhalb einer Benutzersitzung zu beschr√§nken. Unter Sicherheitsaspekten ist die Verwendung von SessionStorage in der Regel LocalStorage vorzuziehen. Wie bei LocalStorage gelten auch bei SessionStorage die Vorteile der Unterst√ºtzung der Same-Origin-Policy und des geringeren Client-Server-Verkehrs.
¬†

**Cookies**

Cookies sind die traditionellere Methode zur Speicherung von Sitzungsdaten. F√ºr jedes Cookie k√∂nnen Sie eine Ablaufzeit festlegen, was die Widerrufbarkeit erleichtert und den Zugriff einschr√§nkt. Allerdings steigt der Client-Server-Verkehr bei der Verwendung von Cookies deutlich an, da die Daten bei jeder HTTP-Anfrage an den Server gesendet werden. Wenn Sie Cookies verwenden, m√ºssen Sie sich gegen Session Hijacking sch√ºtzen. Standardm√§√üig werden Cookies im Klartext √ºber HTTP √ºbertragen, wodurch ihre Inhalte anf√§llig f√ºr Packet Sniffing und/oder Man-in-the-Middle-Angriffe sind, bei denen Angreifer Ihren Datenverkehr manipulieren k√∂nnen. Sie sollten stets HTTPS erzwingen, um Ihre Daten w√§hrend der √úbertragung zu sch√ºtzen. Dies gew√§hrleistet Vertraulichkeit, Integrit√§t (der Daten) und Authentifizierung. Ist Ihre Webanwendung oder Website sowohl √ºber HTTP als auch √ºber HTTPS erreichbar, sollten Sie au√üerdem das ‚ÄûSecure‚Äú-Flag beim Cookie verwenden. So wird verhindert, dass Angreifer einem Benutzer Links zur HTTP-Version Ihrer Seite senden und die daraus resultierende HTTP-Anfrage abh√∂ren k√∂nnen.

Eine weitere sekund√§re Schutzma√ünahme gegen Session Hijacking bei der Verwendung von Cookies besteht darin, die Identit√§t des Benutzers erneut zu verifizieren, bevor Ma√ünahmen mit hoher Auswirkung durchgef√ºhrt werden. Ein weiteres Flag, das Sie zur Verbesserung der Sicherheit Ihrer Cookies in Betracht ziehen sollten, ist das ‚ÄûHttpOnly‚Äú-Flag. Dieses Flag weist den Browser an, dass das betreffende Cookie nur vom angegebenen Server zug√§nglich sein soll. Jeder Zugriff durch clientseitige Skripte wird durch dieses Flag unterbunden und hilft damit, die meisten Cross-Site-Scripting-(XSS)-Angriffe zu verhindern.