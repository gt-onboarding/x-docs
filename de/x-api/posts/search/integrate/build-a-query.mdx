---
title: Eine Abfrage erstellen
sidebarTitle: Eine Abfrage erstellen
---

<div id="building-queries-for-search-posts">
  ## Abfragen f√ºr die Postsuche erstellen
</div>

Die Suchendpunkte akzeptieren eine einzelne Abfrage per GET-Anfrage und liefern eine Menge historischer Posts, die mit der Abfrage √ºbereinstimmen. Abfragen bestehen aus Operatoren, mit denen verschiedene Post-Attribute abgeglichen werden.¬†

<div id="table-of-contents">
  ### Inhaltsverzeichnis
</div>

- [Eine Abfrage erstellen](#build)
- [Einschr√§nkungen von Abfragen](#limits)
- [Verf√ºgbarkeit von Operatoren](#availability)
- [Operatortypen: eigenst√§ndig und konjunktionspflichtig](#types)
- [Boolesche Operatoren und Gruppierung](#boolean)
- [Reihenfolge der Auswertung](#order-of-operations)
- [Zeichensetzung, Diakritika und Gro√ü-/Kleinschreibung](#punctuation)
- [Spezifizit√§t und Effizienz](#specificity)
- [Abgleichsverhalten bei Quote-Tweets](#quote-tweets)
- [Eine Abfrage iterativ aufbauen](#iterative)
- [Eine Abfrage zu Ihrer Anfrage hinzuf√ºgen](#adding-a-query)
- [Abfragebeispiele](#examples)
- [Liste der Operatoren](#list)

<div id="building-a-query">
  ### Erstellen einer Abfrage
</div>

<div id="query-limitations">
  #### Abfragebeschr√§nkungen
</div>

Ihre Abfragen sind abh√§ngig von der verwendeten [Zugriffsebene](/de/x-api/getting-started/about-x-api) eingeschr√§nkt.

Mit Basic- oder Pro-Zugriff darf Ihre Abfrage f√ºr den Recent-Search-Endpunkt bis zu 512 Zeichen lang sein.

Mit Pro-Zugriff darf Ihre Abfrage f√ºr den Full-Archive-Search-Endpunkt bis zu 1.024 Zeichen lang sein.¬†

<div id="operator-availability">
  #### Verf√ºgbarkeit von Operatoren
</div>

W√§hrend die meisten Operatoren allen Entwicklern zur Verf√ºgung stehen, sind einige bestimmten Zugriffsstufen vorbehalten. In der [Operatorenliste](/de/x-api/posts/search/integrate/build-a-query) geben wir mithilfe der folgenden Bezeichnungen an, f√ºr welche Zugriffsstufe jeder Operator verf√ºgbar ist:

- **Kernoperatoren:** Verf√ºgbar bei Verwendung beliebiger [Projekte](/de/resources/fundamentals/projects).
- **Erweiterte Operatoren:** Verf√ºgbar bei Verwendung eines Projekts mit einer bestimmten Zugriffsstufe

<div id="operator-types-standalone-and-conjunction-required">
  #### Operator-Typen: eigenst√§ndig und konjunktionserforderlich
</div>

**Eigenst√§ndige Operatoren** k√∂nnen allein oder zusammen mit beliebigen anderen Operatoren verwendet werden (einschlie√ülich solcher, die eine Konjunktion erfordern).

Zum Beispiel funktioniert die folgende Abfrage, da sie den Operator `#hashtag` verwendet, der eigenst√§ndig ist:

`#xapiv2`

**Konjunktionserforderliche** Operatoren k√∂nnen in einer Abfrage nicht allein verwendet werden; sie k√∂nnen nur verwendet werden, wenn mindestens ein eigenst√§ndiger Operator in der Abfrage enthalten ist. Der Grund ist, dass ihre alleinige Verwendung viel zu allgemein w√§re und auf ein extrem hohes Volumen an Posts zutreffen w√ºrde.

Die folgenden Abfragen werden beispielsweise nicht unterst√ºtzt, da sie nur konjunktionserforderliche Operatoren enthalten:

`has:media`

`has:links OR is:retweet`

Wenn wir einen eigenst√§ndigen Operator hinzuf√ºgen, etwa die Phrase `"X data"`, w√ºrde die Abfrage ordnungsgem√§√ü funktionieren.

`"X data" has:mentions (has:media OR has:links)`

<div id="boolean-operators-and-grouping">
  #### Boolesche Operatoren und Gruppierung
</div>

Wenn Sie mehrere Operatoren in einer einzigen Abfrage verketten m√∂chten, stehen Ihnen die folgenden Werkzeuge zur Verf√ºgung:

|     |     |
| :--- | :--- |
| **UND-Logik** | Aufeinanderfolgende Operatoren mit einem Leerzeichen dazwischen f√ºhren zu boolescher UND-Logik. Das bedeutet, dass Posts nur √ºbereinstimmen, wenn beide Bedingungen erf√ºllt sind. Zum Beispiel matched `snow day #NoSchool` nur Posts, die die Begriffe snow und day sowie den Hashtag #NoSchool enthalten. |
| **ODER-Logik** | Aufeinanderfolgende Operatoren mit OR dazwischen f√ºhren zu ODER-Logik, das hei√üt, Posts stimmen √ºberein, wenn eine der Bedingungen erf√ºllt ist. Wenn Sie zum Beispiel `grumpy OR cat OR #meme` angeben, werden alle Posts erfasst, die mindestens die Begriffe grumpy oder cat oder den Hashtag #meme enthalten. |
| **NICHT-Logik, Negation** | Stellen Sie einem Schl√ºsselwort (oder einem beliebigen Operator) einen Bindestrich (-) voran, um es zu negieren (NOT). Zum Beispiel matched `cat #meme -grumpy` Posts, die den Hashtag #meme und den Begriff cat enthalten, jedoch nur, wenn sie nicht den Begriff grumpy enthalten. Eine g√§ngige Abfrageklausel ist `-is:retweet`, die nicht auf Retweets matched und somit nur auf originale Posts, Quote Tweets und Antworten. Alle Operatoren k√∂nnen negiert werden, aber negierte Operatoren d√ºrfen nicht allein verwendet werden. |
| **Gruppierung** | Sie k√∂nnen Klammern verwenden, um Operatoren zu gruppieren. Zum Beispiel liefert `(grumpy cat) OR (#meme has:images)` entweder Posts, die die Begriffe grumpy und cat enthalten, oder Posts mit Bildern, die den Hashtag #meme enthalten. Beachten Sie, dass zuerst UND und anschlie√üend ODER angewendet wird. |

**Hinweis zu Negationen**

Der Operator `is:nullcast` muss immer negiert werden.

Negierte Operatoren d√ºrfen nicht allein verwendet werden.

Negieren Sie nicht eine Menge von Operatoren, die zusammen in Klammern gruppiert sind. Negieren Sie stattdessen jeden einzelnen Operator. Verwenden Sie zum Beispiel anstelle von `skiing -(snow OR day OR noschool)` besser `skiing -snow -day -noschool`.¬†

<div id="order-of-operations">
  #### Reihenfolge der Auswertung
</div>

Beim Kombinieren von AND- und OR-Funktionen bestimmt die folgende Auswertungsreihenfolge, wie Ihre Abfrage interpretiert wird.

1. Zuerst werden Operatoren kombiniert, die durch AND-Logik verbunden sind
2. Danach werden Operatoren angewendet, die durch OR-Logik verbunden sind

Beispiele:

- `apple OR iphone ipad` wird als `apple OR (iphone ipad)` ausgewertet
- `ipad iphone OR android` wird als `(iphone ipad) OR android` ausgewertet

Um Unklarheiten zu vermeiden und sicherzustellen, dass Ihre Abfrage wie beabsichtigt ausgewertet wird, gruppieren Sie Begriffe nach Bedarf mit Klammern.

Beispiele:

- `(apple OR iphone) ipad`
- `iphone (ipad OR android)`

<div id="punctuation-diacritics-and-case-sensitivity">
  #### Interpunktion, Diakritika und Gro√ü-/Kleinschreibung
</div>

Wenn Sie eine Keyword- oder Hashtag-Abfrage mit Akzenten oder Diakritika angeben, werden Beitr√§ge gefunden, die sowohl den Begriff mit Akzenten/Diakritika als auch den entsprechenden Begriff mit normalen Zeichen enthalten. Beispielsweise finden Abfragen mit dem Keyword `Diacr√≠tica` oder dem Hashtag `#cumplea√±os` sowohl _Diacr√≠tica_ bzw. _#cumplea√±os_ als auch _Diacritica_ bzw. _#cumpleanos_ ohne die Tilde √ºber √≠ oder das e√±e.

Zeichen mit Akzenten oder Diakritika werden wie normale Zeichen behandelt und nicht als Wortgrenzen. Eine Abfrage mit dem Keyword `cumplea√±os` w√ºrde beispielsweise nur Aktivit√§ten finden, die das Wort _cumplea√±os_ enthalten, und nicht Aktivit√§ten, die _cumplea_, _cumplean_ oder _os_ enthalten.

Alle Operatoren werden ohne Ber√ºcksichtigung der Gro√ü- und Kleinschreibung ausgewertet. Beispielsweise findet die Abfrage `cat` Beitr√§ge mit allen folgenden Varianten: _cat_, _CAT_, _Cat_.

Das Matching-Verhalten des [Gefilterten Streams](/de/x-api/posts/filtered-stream) unterscheidet sich von dem der Posts-Suche. Beim [Erstellen einer Regel f√ºr den Gefilterten Stream](/de/x-api/posts/filtered-stream#building-rules-for-filtered-stream) gilt: Keywords und Hashtags mit Akzenten oder Diakritika stimmen nur mit Begriffen √ºberein, die ebenfalls den Akzent bzw. das Diakritikum enthalten, und nicht mit Begriffen, die stattdessen normale Zeichen verwenden.

Beispielsweise stimmen Regeln f√ºr den Gefilterten Stream, die ein Keyword `Diacr√≠tica` oder den Hashtag `#cumplea√±os` enthalten, nur mit den Begriffen _Diacr√≠tica_ und _#cumplea√±os_ √ºberein und nicht mit _Diacritica_ oder _#cumpleanos_ ohne die Tilde √ºber √≠ oder das e√±e.

<div id="specificity-and-efficiency">
  #### Spezifit√§t und Effizienz
</div>

Wenn Sie mit dem Erstellen Ihrer Abfrage beginnen, sollten Sie ein paar Dinge beachten.

- Die Verwendung breiter, eigenst√§ndiger Operatoren wie eines einzelnen Schl√ºsselworts oder #Hashtags wird im Allgemeinen nicht empfohlen, da dies wahrscheinlich zu einer enormen Anzahl passender Posts f√ºhrt. Eine robustere Abfrage liefert ein spezifischeres Set √ºbereinstimmender Posts und reduziert idealerweise das Rauschen in der Nutzlast, durch das Sie sich arbeiten m√ºssen, um wertvolle Erkenntnisse zu gewinnen.
  - Wenn Ihre Abfrage beispielsweise nur das Schl√ºsselwort `happy` enth√§lt, erhalten Sie wahrscheinlich zwischen 200.000 und 300.000 Posts pro Tag.
  - Das Hinzuf√ºgen weiterer bedingter Operatoren verengt Ihre Suchergebnisse, zum Beispiel: `(happy OR happiness) place_country:GB -birthday -is:retweet`
- Effiziente Abfragen helfen auch dabei, die Zeichenl√§ngenbeschr√§nkung f√ºr Abfragen einzuhalten. Die Zeichenz√§hlung umfasst die gesamte Abfragezeichenkette, einschlie√ülich Leerzeichen und Operatoren.
  - Beispielsweise ist die folgende Abfrage 59 Zeichen lang: `(happy OR happiness) place_country:GB -birthday -is:retweet`

<div id="quote-tweet-matching-behavior">
  #### √úbereinstimmungsverhalten bei zitierten Posts (Quote Tweets)
</div>

Bei der Verwendung der Search-Posts-Endpunkte greifen Operatoren nicht auf den Inhalt des urspr√ºnglich zitierten Posts zu, sondern nur auf den im Quote Tweet enthaltenen Inhalt.

Bitte beachten Sie jedoch, dass der [Gefilterte Stream](/de/x-api/posts/filtered-stream) sowohl den Inhalt des urspr√ºnglich zitierten Posts als auch den Inhalt des Quote Tweets ber√ºcksichtigt.

<div id="iteratively-building-a-query">
  #### Eine Abfrage iterativ aufbauen
</div>

<div id="test-your-query-early-and-often">
  ##### Testen Sie Ihre Abfrage fr√ºhzeitig und regelm√§√üig
</div>

Es ist selten, dass eine Abfrage beim ersten Mal die ‚Äûrichtigen‚Äú Ergebnisse liefert. Auf X gibt es so viel, das anfangs vielleicht nicht offensichtlich ist, und die oben beschriebene Abfragesyntax l√§sst sich m√∂glicherweise nur schwer mit Ihrer gew√ºnschten Suche in Einklang bringen. W√§hrend Sie eine Abfrage erstellen, ist es wichtig, sie regelm√§√üig zu testen.

F√ºr diesen Abschnitt beginnen wir mit der folgenden Abfrage und passen sie anhand der Ergebnisse an, die wir w√§hrend unseres Tests erhalten:

`happy OR happiness`

<div id="use-results-to-narrow-the-query">
  ##### Ergebnisse nutzen, um die Abfrage zu verfeinern
</div>

W√§hrend Sie die Abfrage testen, sollten Sie die zur√ºckgegebenen Posts pr√ºfen, um festzustellen, ob sie die erwarteten Daten enthalten. Wenn Sie mit einer breiten Abfrage und einer Obermenge an Post-Treffern beginnen, k√∂nnen Sie das Ergebnis sichten und die Abfrage verfeinern, um unerw√ºnschte Treffer herauszufiltern.¬†¬†

Als wir die Beispielabfrage getestet haben, ist uns aufgefallen, dass wir Posts in einer Vielzahl unterschiedlicher Sprachen erhielten. In diesem Fall m√∂chten wir nur Posts auf Englisch erhalten, daher f√ºgen wir den Operator `lang:` hinzu:

`(happy OR happiness) lang:en`

Der Test lieferte eine Reihe von Posts, in denen Leuten ein ‚Äûhappy birthday‚Äú gew√ºnscht wurde, daher f√ºgen wir `-birthday` als negierten Keyword-Operator hinzu. Au√üerdem m√∂chten wir nur originale Posts erhalten, daher haben wir den negierten Operator `-is:retweet` hinzugef√ºgt:

`(happy OR happiness) lang:en -birthday -is:retweet`

<div id="adjust-for-inclusion-where-needed">
  ##### Bei Bedarf auf Einschluss anpassen
</div>

Wenn Sie feststellen, dass Sie nicht die erwarteten Daten erhalten und wissen, dass es vorhandene Posts gibt, die zur√ºckgegeben werden sollten, sollten Sie Ihre Abfrage m√∂glicherweise erweitern, indem Sie Operatoren entfernen, die die gew√ºnschten Daten herausfiltern.

In unserem Beispiel haben wir bemerkt, dass es in unserer pers√∂nlichen Timeline weitere Posts gab, die die gesuchte Emotion ausdr√ºckten und nicht in die Testergebnisse aufgenommen wurden. Um eine umfassendere Abdeckung sicherzustellen, f√ºgen wir die Schl√ºsselw√∂rter `excited` und `elated` hinzu.

`(happy OR happiness OR excited OR elated) lang:en -birthday -is:retweet`

<div id="adjust-for-popular-trendsbursts-over-the-time-period">
  ##### Ber√ºcksichtigen Sie popul√§re Trends/Spitzen im betrachteten Zeitraum
</div>

Trends kommen und gehen auf X schnell. Die Pflege Ihrer Abfrage sollte ein aktiver Prozess sein. Wenn Sie eine Abfrage √ºber einen l√§ngeren Zeitraum nutzen m√∂chten, empfehlen wir, die eingehenden Daten regelm√§√üig zu √ºberpr√ºfen, um festzustellen, ob Anpassungen erforderlich sind.

In unserem Beispiel stellen wir fest, dass wir einige Posts erhalten, in denen Menschen ‚Äûhappy holidays‚Äú w√ºnschen. Da wir diese Posts nicht in unseren Ergebnissen haben m√∂chten, f√ºgen wir ein negiertes `-holidays`-Keyword hinzu.

`(happy OR happiness OR excited OR elated) lang:en -birthday -is:retweet -holidays`

<div id="adding-a-query-to-your-request">
  ### Eine Abfrage zu Ihrer Anfrage hinzuf√ºgen
</div>

Um Ihre Abfrage zu Ihrer Anfrage hinzuzuf√ºgen, m√ºssen Sie den Parameter `query` verwenden. Wie bei allen Query-Parametern m√ºssen Sie sicherstellen, dass die von Ihnen erstellte Abfrage HTTP-codiert ist.

Hier sehen Sie ein Beispiel mit einem cURL-Befehl, in dem zus√§tzlich die Parameter `tweet.fields` und `max_results` enthalten sind. Wenn Sie diesen Befehl verwenden m√∂chten, ersetzen Sie bitte `$BEARER_TOKEN` durch Ihr eigenes [Bearer-Token](/de/resources/fundamentals/authentication#oauth-2-0).

```bash
curl https://api.x.com/2/tweets/search/recent?query=cat%20has%3Amedia%20-grumpy&tweet.fields=created_at&max_results=100 -H "Authorization: Bearer $BEARER_TOKEN"
```

<div id="query-examples">
  ### Abfragebeispiele
</div>

<div id="tracking-a-natural-disaster">
  #### Nachverfolgung einer Naturkatastrophe
</div>

Die folgende Abfrage stimmt mit originalen Posts von Wetterbeh√∂rden und Pegeln √ºberein, die √ºber Hurrikan Harvey sprechen, der 2017 Houston traf.

So w√ºrde die Abfrage ohne HTTP-Codierung aussehen:

`has:geo (from:NWSNHC OR from:NHC\_Atlantic OR from:NWSHouston OR from:NWSSanAntonio OR from:USGS\_TexasRain OR from:USGS_TexasFlood OR from:JeffLindner1) -is:retweet`

Und so w√ºrde die Abfrage mit der HTTP-Codierung, dem Query-Parameter und der URI f√ºr die j√ºngste Suche aussehen:

`https://api.x.com/2/tweets/search/recent?query=-is%3Aretweet%20has%3Ageo%20(from%3ANWSNHC%20OR%20from%3ANHC\_Atlantic%20OR%20from%3ANWSHouston%20OR%20from%3ANWSSanAntonio%20OR%20from%3AUSGS\_TexasRain%20OR%20from%3AUSGS_TexasFlood%20OR%20from%3AJeffLindner1)`

<div id="reviewing-the-sentiment-of-a-conversation">
  #### √úberpr√ºfung der Stimmung einer Unterhaltung
</div>

Die n√§chste Regel k√∂nnte verwendet werden, um die Stimmung der sich um den Hashtag ‚Äû#nowplaying‚Äú entwickelnden Unterhaltung besser zu verstehen, jedoch beschr√§nkt auf Posts, die in Nordamerika ver√∂ffentlicht wurden.

So w√ºrden die zwei unterschiedlichen Abfragen, eine f√ºr positive und eine f√ºr negative Stimmung, ohne HTTP-Encoding aussehen:

`#nowplaying (happy OR exciting OR excited OR favorite OR fav OR amazing OR lovely OR incredible) (place\_country:US OR place\_country:MX OR place_country:CA) -horrible -worst -sucks -bad -disappointing`

`#nowplaying (horrible OR worst OR sucks OR bad OR disappointing) (place\_country:US OR place\_country:MX OR place_country:CA) -happy -exciting -excited -favorite -fav -amazing -lovely -incredible`

Und so w√ºrde die Abfrage mit HTTP-Encoding, dem Query-Parameter und der Recent-Search-URI aussehen:

`https://api.x.com/2/tweets/search/recent?query=%23nowplaying%20(happy%20OR%20exciting%20OR%20excited%20OR%20favorite%20OR%20fav%20OR%20amazing%20OR%20lovely%20OR%20incredible)%20(place\_country%3AUS%20OR%20place\_country%3AMX%20OR%20place_country%3ACA)%20-horrible%20-worst%20-sucks%20-bad%20-disappointing`

`https://api.x.com/2/tweets/search/recent?query=%23nowplaying%20(horrible%20OR%20worst%20OR%20sucks%20OR%20bad%20OR%20disappointing)%20(place\_country%3AUS%20OR%20place\_country%3AMX%20OR%20place_country%3ACA)%20-happy%20-exciting%20-excited%20-favorite%20-fav%20-amazing%20-lovely%20-incredible`

<div id="find-posts-that-relate-to-a-specific-post-annotation">
  #### Finde Posts, die sich auf eine bestimmte Post-Annotation beziehen
</div>

Diese Regel wurde erstellt, um nach Original-Posts zu suchen, die ein Bild eines Haustiers enthalten, das keine Katze ist, wobei die im Post identifizierte Sprache Japanisch ist. Daf√ºr haben wir den Operator `context:` verwendet, um die Funktionalit√§t der [Post-Annotation](/de/x-api/fundamentals/post-annotations) zu nutzen. Zun√§chst haben wir den Endpoint [Post Lookup](/de/x-api/posts/lookup/introduction) und den Feld-Parameter `tweet.fields=context_annotations` verwendet, um zu ermitteln, welche domain.entity-IDs wir in unserer Abfrage verwenden m√ºssen:

- Posts, die sich auf Katzen beziehen, geben `domain` 66 (Kategorie Interessen und Hobbys) mit der Entity 852262932607926273 (Cats) zur√ºck.
- Posts, die sich auf Haustiere beziehen, geben `domain` 65 (Interessen und Hobbys ‚Äì Vertical) mit der Entity 852262932607926273 (Pets) zur√ºck.

So w√ºrde die Abfrage ohne HTTP-Encoding aussehen:

`context:65.852262932607926273 -context:66.852262932607926273 -is:retweet has:images lang:ja`

Und so w√ºrde die Abfrage mit HTTP-Encoding, dem Query-Parameter und der URI f√ºr die j√ºngste Suche aussehen:

`https://api.x.com/2/tweets/search/recent?query=context%3A65.852262932607926273%20-context%3A66.852262932607926273%20-is%3Aretweet%20has%3Aimages%20lang%3Aja`

Probiere das [Query-Builder-Tool](https://developer.x.com/apitools/query?query=) f√ºr zus√§tzliche Unterst√ºtzung aus.¬†

<div id="operators">
  ### Operatoren
</div>

<Note>**Hinweis:** F√ºr einige Operatoren ist ein alternativer Name bzw. Alias verf√ºgbar.</Note>

| **Operator** | **Typ** | **Beschreibung** |
|:-------------|:---------|:-----------------|
| `keyword` | Eigenst√§ndig | Findet ein Schl√ºsselwort im Text eines Posts. Dies ist ein tokenisierter Abgleich, d. h., Ihre Schl√ºsselwortzeichenfolge wird mit dem tokenisierten Text des Post-Texts abgeglichen. Bei der Tokenisierung werden W√∂rter anhand von Satzzeichen, Symbolen und Unicode-Separatorzeichen der Basic Multilingual Plane getrennt.<br /><br />Beispiel: Ein Post mit dem Text ‚ÄûI like coca-cola‚Äú w√ºrde in die folgenden Tokens aufgeteilt: I, like, coca, cola. Diese Tokens w√ºrden dann mit der in Ihrer Abfrage verwendeten Schl√ºsselwortzeichenfolge verglichen. Um Zeichenfolgen mit Satzzeichen (z. B. coca-cola), Symbolen oder Trennzeichen abzugleichen, m√ºssen Sie Ihr Schl√ºsselwort in doppelte Anf√ºhrungszeichen setzen.<br /><br />Beispiel: `pepsi OR cola OR "coca cola"` |
| `emoji` | Eigenst√§ndig | Findet ein Emoji im Text eines Posts. √Ñhnlich wie bei einem Schl√ºsselwort ist auch der Abgleich von Emojis tokenisiert, d. h., Ihr Emoji wird mit dem tokenisierten Text des Post-Texts abgeglichen.<br /><br />Beachten Sie: Wenn ein Emoji eine Variante hat, m√ºssen Sie es in doppelte Anf√ºhrungszeichen setzen, um es zu einer Abfrage hinzuzuf√ºgen.<br /><br />Beispiel: `(üòÉ OR üò°) üò¨` |
| `"exact phrase match"` | Eigenst√§ndig | Findet die exakte Wortgruppe im Text eines Posts.<br /><br />Beispiel: `("X API" OR #v2) -"recent search"` |
| `#` | Eigenst√§ndig | Findet jeden Post mit einem erkannten Hashtag, sofern der Hashtag als Entit√§t im Post erkannt wird.<br /><br />Dieser Operator f√ºhrt einen exakten Abgleich aus, NICHT einen tokenisierten. Das bedeutet, die Regel `#thanku` trifft auf Posts mit genau dem Hashtag #thanku zu, nicht jedoch auf solche mit dem Hashtag #thankunext.<br /><br />Beispiel: `#thankunext #fanart OR @arianagrande` |
| `@` | Eigenst√§ndig | Findet jeden Post, der den angegebenen Nutzernamen erw√§hnt, sofern der Nutzername als Entit√§t erkannt wird (einschlie√ülich des @-Zeichens).<br /><br />Beispiel: `(@XDevelopers OR @API) -@X` |
| `$` | Eigenst√§ndig | Findet jeden Post, der das angegebene ‚ÄûCashtag‚Äú enth√§lt (bei dem das f√ºhrende Zeichen des Tokens das $-Zeichen ist).<br /><br />Beachten Sie, dass sich der Cashtag-Operator auf die ‚Äûsymbols‚Äú-Entit√§tsextraktion von X st√ºtzt, um Cashtags zu erkennen, anstatt zu versuchen, das Cashtag direkt aus dem Text zu extrahieren.<br /><br />Beispiel: `$twtr OR @XDevelopers -$fb` |
| `from:` | Eigenst√§ndig | Findet jeden Post eines bestimmten Nutzers.<br />Der Wert kann entweder der Nutzername (ohne das @-Zeichen) oder die numerische Nutzer-ID sein.<br /><br />Pro `from:`-Operator k√∂nnen Sie nur einen einzelnen Nutzernamen bzw. eine einzelne ID √ºbergeben.<br /><br />Beispiel: `from:XDevelopers OR from:API -from:X` |
| `to:` | Eigenst√§ndig | Findet jeden Post, der als Antwort an einen bestimmten Nutzer gerichtet ist.<br />Der Wert kann entweder der Nutzername (ohne das @-Zeichen) oder die numerische Nutzer-ID sein.<br /><br />Pro `to:`-Operator k√∂nnen Sie nur einen einzelnen Nutzernamen bzw. eine einzelne ID √ºbergeben.<br /><br />Beispiel: `to:XDevelopers OR to:API -to:X` |
| `url:` | Eigenst√§ndig | F√ºhrt einen tokenisierten Abgleich f√ºr jede g√ºltig formatierte URL eines Posts durch.<br /><br />Dieser Operator gleicht den Inhalt sowohl der Felder `url` als auch `expanded_url` ab. Ein Post mit ‚ÄûYou should check out X Developer Labs: https://t.co/c0A36SWil4‚Äú (wobei die Kurz-URL auf https://developer.twitter.com weiterleitet) entspricht beispielsweise beiden folgenden Regeln:<br /><br />`from:XDevelopers url:"https://developer.twitter.com"` (weil der Inhalt von `entities.urls.expanded_url` √ºbereinstimmt)<br /><br />`from:XDevelopers url:"https://t.co"` (weil der Inhalt von `entities.urls.url` √ºbereinstimmt)<br /><br />Tokens und Wortgruppen mit Satzzeichen oder Sonderzeichen sollten in doppelte Anf√ºhrungszeichen gesetzt werden (z. B. `url:"/developer"`). Um auf ein bestimmtes Protokoll abzugleichen, setzen Sie dieses ebenfalls in doppelte Anf√ºhrungszeichen (z. B. `url:"https://developer.twitter.com"`). |
| `retweets_of:` | Eigenst√§ndig | Findet Posts, die Retweets des angegebenen Nutzers sind. Der Wert kann entweder der Nutzername (ohne das @-Zeichen) oder die numerische Nutzer-ID sein.<br /><br />Pro `retweets_of:`-Operator k√∂nnen Sie nur einen einzelnen Nutzernamen bzw. eine einzelne ID √ºbergeben.<br /><br />Beispiel: `retweets_of:twitterdev OR retweets_of:twitterapi` |
| `in_reply_to_tweet_id:` | Eigenst√§ndig | _Verf√ºgbares Alias:_ `in_reply_to_status_id:`<br />Erfasst Antworten auf den angegebenen Post.<br /><br />Beispiel: `in_reply_to_tweet_id:1539382664746020864` |
| `retweets_of_tweet_id:` | Eigenst√§ndig | _Verf√ºgbares Alias:_ `retweets_of_status_id:`<br />Erfasst explizite (native) Retweets des angegebenen Posts. Beachten Sie, dass die verwendete Post-ID die ID eines urspr√ºnglichen Posts und nicht eines Retweets sein muss.<br /><br />Beispiel: `retweets_of_tweet_id:1539382664746020864` |
| `quotes_of_tweet_id:` | Eigenst√§ndig | _Verf√ºgbares Alias:_ `quotes_of_status_id:`<br />Erfasst Zitat-Posts des angegebenen Posts. Beachten Sie, dass die verwendete Post-ID die ID eines urspr√ºnglichen Posts und nicht eines Zitat-Posts sein muss.<br /><br />Beispiel: `quotes_of_tweet_id:1539382664746020864` |
| `context:` | Eigenst√§ndig | Erfasst Posts mit einem bestimmten Domain-ID/Entity-ID-Paar. Weitere Informationen zu diesem Operator finden Sie auf unserer Seite zu [Annotationen](/de/x-api/fundamentals/post-annotations).<br /><br />Pro `context:`-Operator kann nur eine einzelne Domain/Entity √ºbergeben werden.<br /><br />`context:domain_id.entity_id`<br /><br />Sie k√∂nnen jedoch mehrere Domains/Entities mit dem OR-Operator kombinieren:<br /><br />`(context:47.1139229372198469633 OR context:11.1088514520308342784)`<br /><br />Beispiele:<br />`context:10.799022225751871488` (`domain_id.entity_id` gibt Posts zur√ºck, die genau mit diesem Domain-Entity-Paar √ºbereinstimmen) |
| `entity:` | Eigenst√§ndig | Erfasst Posts mit einem bestimmten Entity-Zeichenfolgenwert. Weitere Informationen zu diesem Operator finden Sie auf unserer Seite zu [Annotationen](/de/x-api/fundamentals/post-annotations).<br />**Bitte beachten:** Dies ist nur in der j√ºngsten Suche verf√ºgbar.<br /><br />Sie k√∂nnen nur einen einzelnen `entity:`-Operator verwenden.<br /><br />`entity:"Zeichenfolgendeklaration von Entity/Ort"`<br /><br />Beispiele: `entity:"Michael Jordan" OR entity:"Barcelona"` |
| `conversation_id:` | Eigenst√§ndig | Erfasst Posts, die dieselbe Konversations-ID teilen. Eine Konversations-ID entspricht der Post-ID des Posts, der eine Konversation gestartet hat. Wenn Antworten auf einen Post ver√∂ffentlicht werden ‚Äì auch Antworten auf Antworten ‚Äì wird die `conversation_id` der JSON-Nutzlast hinzugef√ºgt.<br /><br />Pro `conversation_id:`-Operator kann nur eine einzelne Konversations-ID √ºbergeben werden.<br /><br />Beispiel: `conversation_id:1334987486343299072 (from:XDevelopers OR from:api)` |
| `list:` | Eigenst√§ndig | **NEU** Erfasst Posts, die von Nutzern ver√∂ffentlicht wurden, die Mitglieder einer angegebenen Liste sind.<br /><br />Wenn beispielsweise @XDevelopers und @api Mitglieder der Liste 123 w√§ren und Sie `list:123` in Ihre Abfrage aufnehmen, enth√§lt Ihre Antwort nur Posts, die von diesen Accounts ver√∂ffentlicht wurden. Listen-IDs finden Sie √ºber den Endpunkt [List lookup](/de/x-api/lists/list-lookup/introduction).<br /><br />**Bitte beachten:** Pro Abfrage kann nur ein einzelner `list:`-Operator verwendet werden, und pro `list:`-Operator kann nur eine einzelne Liste angegeben werden.<br /><br />Beispiel: `list:123` |
| `place:` | Eigenst√§ndig | Erfasst Posts, die mit dem angegebenen Ort oder der X-Place-ID getaggt sind. Mehrwort-Ortsnamen (‚ÄûNew York City‚Äú, ‚ÄûPalo Alto‚Äú) sollten in Anf√ºhrungszeichen gesetzt werden.<br /><br />Pro `place:`-Operator kann nur ein einzelner Ort √ºbergeben werden.<br /><br />Hinweis: Informationen zum Abrufen von X-Place-IDs finden Sie im Standard-Endpunkt v1.1 [GET geo/search](https://developer.x.com/content/developer-twitter/en/docs/geo/places-near-location/api-reference/get-geo-search).<br /><br />Hinweis: Dieser Operator erfasst keine Retweets, da die Orte von Retweets dem urspr√ºnglichen Post zugeordnet sind. Er erfasst auch keine Orte, die dem urspr√ºnglichen Post eines Zitat-Posts zugeordnet sind.<br /><br />Beispiel: `place:"new york city" OR place:seattle OR place:fd70c22040963ac7` |
| `place_country:` | Eigenst√§ndig | Findet Posts, bei denen der L√§ndercode des getaggten Orts/Standorts dem angegebenen ISO-Alpha-2-Code entspricht.<br /><br />Eine Liste g√ºltiger ISO-Codes finden Sie auf [Wikipedia](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2).<br /><br />Pro Operator `place_country:` kann nur ein einzelner ISO-Code √ºbergeben werden.<br /><br />Hinweis: Dieser Operator erfasst keine Retweets, da deren Orte am urspr√ºnglichen Post h√§ngen. Er erfasst auch keine Orte, die am urspr√ºnglichen Post eines Quote-Tweets h√§ngen.<br /><br />Beispiel: `place_country:US OR place_country:MX OR place_country:CA` |
| `point_radius:` | Eigenst√§ndig | Pr√ºft das Objekt `place.geo.coordinates` des Posts, sofern vorhanden, und in X ein Orts-Geo-Polygon, wobei das Orts‚ÄëPolygon vollst√§ndig innerhalb der definierten Region liegt.<br /><br />`point_radius:[longitude latitude radius]`<br /><br />- Unterst√ºtzte Einheit des Radius: Meilen (mi) und Kilometer (km)<br />- Der Radius muss kleiner als 25 mi sein<br />- L√§nge liegt im Bereich von ¬±180<br />- Breite liegt im Bereich von ¬±90<br />- Alle Koordinaten sind in Dezimalgrad<br />- Regelargumente stehen in eckigen Klammern und sind durch Leerzeichen getrennt<br /><br />Pro Operator `point_radius:` kann nur ein einzelnes Geo‚ÄëPolygon √ºbergeben werden.<br /><br />Hinweis: Dieser Operator erfasst keine Retweets, da deren Orte am urspr√ºnglichen Post h√§ngen. Er erfasst auch keine Orte, die am urspr√ºnglichen Post eines Quote-Tweets h√§ngen.<br /><br />Beispiel: `point_radius:[2.355128 48.861118 16km] OR point_radius:[-41.287336 174.761070 20mi]` |
| `bounding_box:` | Eigenst√§ndig | _Verf√ºglicher Alias:_ `geo_bounding_box:`<br />Pr√ºft das Objekt `place.geo.coordinates` des Posts, sofern vorhanden, und in X ein Orts-Geo-Polygon, wobei das Orts‚ÄëPolygon vollst√§ndig innerhalb der definierten Region liegt.<br /><br />`bounding_box:[west_long south_lat east_long north_lat]`<br /><br />- `west_long south_lat` bilden die s√ºdwestliche Ecke der Bounding Box, wobei `west_long` die L√§nge dieses Punktes und `south_lat` die Breite ist.<br />- `east_long north_lat` bilden die nord√∂stliche Ecke der Bounding Box, wobei `east_long` die L√§nge dieses Punktes und `north_lat` die Breite ist.<br />- Breite und H√∂he der Bounding Box m√ºssen kleiner als 25 mi sein<br />- L√§nge liegt im Bereich von ¬±180<br />- Breite liegt im Bereich von ¬±90<br />- Alle Koordinaten sind in Dezimalgrad.<br />- Regelargumente stehen in eckigen Klammern und sind durch Leerzeichen getrennt.<br /><br />Pro Operator `bounding_box:` kann nur ein einzelnes Geo‚ÄëPolygon √ºbergeben werden.<br /><br />Hinweis: Dieser Operator erfasst keine Retweets, da deren Orte am urspr√ºnglichen Post h√§ngen. Er erfasst auch keine Orte, die am urspr√ºnglichen Post eines Quote-Tweets h√§ngen.<br /><br />Beispiel: `bounding_box:[-105.301758 39.964069 -105.178505 40.09455]` |
| `is:retweet` | Konjunktion erforderlich | Findet Retweets, die den √ºbrigen Teil der angegebenen Regel erf√ºllen. Dieser Operator sucht nur nach echten Retweets (z. B. solchen, die √ºber die Retweet-Schaltfl√§che erzeugt wurden). Quote-Tweets werden von diesem Operator nicht erfasst.<br /><br />Beispiel: `data @XDevelopers -is:retweet` |
| `is:reply` | Konjunktion erforderlich | Liefert nur explizite Antworten, die einer Regel entsprechen. Kann auch negiert werden, um Antworten, die einer Abfrage entsprechen, von der Zustellung auszuschlie√üen.<br /><br />Hinweis: Dieser Operator ist auch beim Endpoint f√ºr den Gefilterten Stream verf√ºgbar. Mit dem Gefilterten Stream erfasst dieser Operator Antworten auf einen urspr√ºnglichen Post, Antworten in Quote-Tweets sowie Antworten in Retweets.<br /><br />Beispiel: `from:XDevelopers is:reply` |
| `is:quote` | Konjunktion erforderlich | Gibt alle Quote-Tweets zur√ºck, also Posts mit Kommentar.<br /><br />Beispiel: `"sentiment analysis" is:quote` |
| `is:verified` | Konjunktion erforderlich | Liefert nur Posts, deren Autorinnen und Autoren von X verifiziert sind.<br /><br />Beispiel: `#nowplaying is:verified` |
| `-is:nullcast` | Konjunktion erforderlich | Entfernt Posts, die ausschlie√ülich zu Werbezwecken auf ads.twitter.com erstellt wurden und deren `"source":"Twitter for Advertisers (legacy)"` oder `"source":"Twitter for Advertisers"` ist.<br />Dieser Operator muss negiert werden.<br /><br />Weitere Informationen zu nullgecasteten Posts finden Sie auf unserer Seite zur [Verf√ºgbarkeit von Posts](https://developer.x.com/content/developer-twitter/en/docs/twitter-api/v1/tweets/post-and-engage/guides/tweet-availability).<br /><br />Beispiel: `"mobile games" -is:nullcast` |
| `has:hashtags` | Konjunktion erforderlich | Findet Posts, die mindestens einen Hashtag enthalten.<br /><br />Beispiel: `from:XDevelopers -has:hashtags` |
| `has:cashtags` | Konjunktion erforderlich | Findet Posts, die ein Cashtag-Symbol enthalten (mit einem f√ºhrenden ‚Äû$‚Äú-Zeichen, z. B. ‚Äû$tag‚Äú).<br /><br />Beispiel: `#stonks has:cashtags` |
| `has:links` | Konjunktion erforderlich | Dieser Operator findet Posts, die Links und Medien im Post-Text enthalten.<br /><br />Beispiel: `from:XDevelopers announcement has:links` |
| `has:mentions` | Konjunktion erforderlich | Findet Posts, die einen anderen X Nutzer erw√§hnen.<br /><br />Beispiel: `#nowplaying has:mentions` |
| `has:media` | Konjunktion erforderlich | Verf√ºgbarer Alias: `has:media_link`<br />Findet Posts, die ein Medienobjekt enthalten, z. B. ein Foto, GIF oder Video, wie von X bestimmt. Dies umfasst keine Medien, die mit Periscope erstellt wurden, oder Posts mit Links zu anderen Medienhosting-Seiten.<br /><br />Beispiel: `(kittens OR puppies) has:media` |
| `has:images` | Konjunktion erforderlich | Findet Posts, die eine erkannte URL zu einem Bild enthalten.<br /><br />Beispiel: `#meme has:images` |
| `has:video_link` | Konjunktion erforderlich | Verf√ºgbarer Alias: `has:videos`<br />Findet Posts, die native X Videos enthalten, die direkt auf X hochgeladen wurden. Dies umfasst keine Videos, die mit Periscope erstellt wurden, oder Posts mit Links zu anderen Video-Hosting-Seiten.<br /><br />Beispiel: `#icebucketchallenge has:video_link` |
| `has:geo` | Konjunktion erforderlich | Findet Posts, die postspezifische Geolokalisierungsdaten enthalten, die vom X Nutzer bereitgestellt wurden. Dies kann entweder ein Ort in Form eines X Place mit entsprechendem Anzeigenamen, Geo-Polygon und anderen Feldern sein oder in seltenen F√§llen eine Geo-L√§ngen-/Breitenkoordinate.<br /><br />Hinweis: Operatoren, die auf Place (Post-Geodaten) pr√ºfen, beinhalten nur Treffer aus urspr√ºnglichen Posts. Retweets enthalten keine Place-Daten.<br /><br />Beispiel: `recommend #paris has:geo -bakery` || `lang:` | Verkn√ºpfung erforderlich | Findet Posts, die von X als in einer bestimmten Sprache verfasst klassifiziert wurden (nur, wenn der Post klassifiziert wurde). Wichtig: Jeder Post ist derzeit genau einer Sprache zugeordnet; das Verkn√ºpfen mehrerer Sprachen mit AND liefert daher keine Ergebnisse.<br /><br />Pro `lang:`-Operator kann nur ein einzelner BCP‚Äë47-Sprachkennzeichner √ºbergeben werden.<br /><br />Hinweis: Wenn keine Sprachklassifizierung m√∂glich ist, lautet das Ergebnis ‚Äûund‚Äú (f√ºr undefined/undefiniert).<br /><br />Beispiel: `recommend #paris lang:en`<br /><br />Die folgende Liste enth√§lt die derzeit unterst√ºtzten Sprachen und ihre jeweiligen BCP‚Äë47‚ÄëSprachkennzeichner:<br /><br />Amharisch: `am` | Deutsch: `de` | Malayalam: `ml` | Slowakisch: `sk`<br />Arabisch: `ar` | Griechisch: `el` | Maledivisch: `dv` | Slowenisch: `sl`<br />Armenisch: `hy` | Gujarati: `gu` | Marathi: `mr` | Sorani-Kurdisch: `ckb`<br />Baskisch: `eu` | Haitianisch-Kreolisch: `ht` | Nepali: `ne` | Spanisch: `es`<br />Bengalisch: `bn` | Hebr√§isch: `iw` | Norwegisch: `no` | Schwedisch: `sv`<br />Bosnisch: `bs` | Hindi: `hi` | Oriya: `or` | Tagalog: `tl`<br />Bulgarisch: `bg` | latinisiertes Hindi: `hi-Latn` | Panjabi: `pa` | Tamil: `ta`<br />Birmanisch: `my` | Ungarisch: `hu` | Paschtu: `ps` | Telugu: `te`<br />Kroatisch: `hr` | Isl√§ndisch: `is` | Persisch: `fa` | Thail√§ndisch: `th`<br />Katalanisch: `ca` | Indonesisch: `in` | Polnisch: `pl` | Tibetisch: `bo`<br />Tschechisch: `cs` | Italienisch: `it` | Portugiesisch: `pt` | Traditionelles Chinesisch: `zh-TW`<br />D√§nisch: `da` | Japanisch: `ja` | Rum√§nisch: `ro` | T√ºrkisch: `tr`<br />Niederl√§ndisch: `nl` | Kannada: `kn` | Russisch: `ru` | Ukrainisch: `uk`<br />Englisch: `en` | Khmer: `km` | Serbisch: `sr` | Urdu: `ur`<br />Estnisch: `et` | Koreanisch: `ko` | Vereinfachtes Chinesisch: `zh-CN` | Uigurisch: `ug`<br />Finnisch: `fi` | Lao: `lo` | Sindhi: `sd` | Vietnamesisch: `vi`<br />Franz√∂sisch: `fr` | Lettisch: `lv` | Singhalesisch: `si` | Walisisch: `cy`<br />Georgisch: `ka` | Litauisch: `lt` |