---
title: Eine Abfrage erstellen
sidebarTitle: Eine Abfrage erstellen
---

<div id="building-a-query">
  #### Eine Abfrage erstellen
</div>

**Einschränkungen für Abfragen**

Ihre Abfragen sind abhängig von der verwendeten [Zugriffsebene](/de/x-api/getting-started/about-x-api) eingeschränkt.

Wenn Sie Pro-Zugriff haben, darf Ihre Abfrage bis zu 512 Zeichen lang sein.

Wenn Sie Enterprise-Zugriff haben, wenden Sie sich bitte an Ihre Account-Managerin bzw. Ihren Account-Manager.

**Verfügbarkeit von Operatoren**

Während die meisten Operatoren allen Entwicklerinnen und Entwicklern zur Verfügung stehen, sind einige für Personen reserviert, die für den Enterprise-Zugriff freigeschaltet wurden. In der Tabelle der [Liste der Operatoren](/de/x-api/posts/search/integrate/build-a-query) ist anhand der folgenden Kennzeichnungen angegeben, für welche Zugriffsebene jeder Operator verfügbar ist:

- Core-Operatoren: Verfügbar bei Verwendung eines beliebigen [Projekts](/de/resources/fundamentals/projects).
- Erweiterte Operatoren: Verfügbar bei Verwendung eines Projekts mit Enterprise-Zugriff 
   

<div id="operator-types-standalone-and-conjunction-required">
  #### Operator-Typen: eigenständig und konjunktionspflichtig
</div>

**Eigenständige Operatoren** können allein oder zusammen mit beliebigen anderen Operatoren verwendet werden (einschließlich solcher, die eine Konjunktion erfordern).

Zum Beispiel funktioniert die folgende Abfrage, weil sie den Operator #hashtag verwendet, der eigenständig ist:

\#xapiv2

**Konjunktionspflichtige** Operatoren können in einer Abfrage nicht allein verwendet werden; sie dürfen nur verwendet werden, wenn mindestens ein eigenständiger Operator in der Abfrage enthalten ist. Der Grund ist, dass die alleinige Nutzung dieser Operatoren viel zu allgemein wäre und eine extrem hohe Anzahl von Posts matchen würde.

Zum Beispiel werden die folgenden Abfragen nicht unterstützt, da sie nur konjunktionspflichtige Operatoren enthalten:

has:media
has:links OR is:retweet

Wenn wir einen eigenständigen Operator hinzufügen, etwa die Phrase „X data“, funktioniert die Abfrage ordnungsgemäß.

„X data“ has:mentions (has:media OR has:links)

<div id="boolean-operators-and-grouping">
  #### Boolesche Operatoren und Gruppierung
</div>

Wenn Sie mehrere Operatoren in einer einzelnen Abfrage verknüpfen möchten, stehen Ihnen die folgenden Möglichkeiten zur Verfügung:

|     |     |
| :--- | :--- |
| **AND-Logik** | Aufeinanderfolgende Operatoren mit einem Leerzeichen dazwischen ergeben eine boolesche AND-Logik. Das bedeutet: Es wird nur dann übereingestimmt, wenn beide Bedingungen erfüllt sind. Beispiel: snow day #NoSchool findet Posts, die die Begriffe snow und day sowie den Hashtag #NoSchool enthalten. |
| **OR-Logik** | Aufeinanderfolgende Operatoren mit OR dazwischen ergeben eine OR-Logik. Das bedeutet: Es wird übereingestimmt, wenn eine der Bedingungen erfüllt ist. Beispiel: grumpy OR cat OR #meme findet alle Posts, die mindestens die Begriffe grumpy oder cat oder den Hashtag #meme enthalten. |
| **NOT-Logik, Negation** | Stellen Sie einem Schlüsselwort (oder einem beliebigen Operator) ein Minuszeichen (-) voran, um es zu negieren (NOT). Beispiel: cat #meme -grumpy findet Posts, die den Hashtag #meme und den Begriff cat enthalten, jedoch nur, wenn sie nicht den Begriff grumpy enthalten. Eine gängige Abfrageklausel ist -is:retweet; diese stimmt nicht auf Retweets ab und erfasst damit nur Original-Posts, Quote Tweets und Antworten. Alle Operatoren können negiert werden, aber negierte Operatoren dürfen nicht allein verwendet werden. |
| **Gruppierung** | Sie können Klammern verwenden, um Operatoren zu gruppieren. Beispiel: (grumpy cat) OR (#meme has:images) gibt entweder Posts zurück, die die Begriffe grumpy und cat enthalten, oder Posts mit Bildern, die den Hashtag #meme enthalten. Beachten Sie: AND wird zuerst angewendet, danach OR. |

**Hinweis zu Negationen**

Der Operator -is:nullcast muss immer negiert werden.

Negierte Operatoren dürfen nicht allein verwendet werden.

Negieren Sie keine Menge von Operatoren, die gemeinsam in Klammern gruppiert sind. Negieren Sie stattdessen jeden einzelnen Operator. Verwenden Sie zum Beispiel statt skiing -(snow OR day OR noschool) besser skiing -snow -day -noschool. 

**Reihenfolge der Auswertung**

Beim Kombinieren von AND- und OR-Funktionalität bestimmt die folgende Auswertungsreihenfolge, wie Ihre Abfrage interpretiert wird.

1. Mit AND-Logik verbundene Operatoren werden zuerst kombiniert
2. Danach werden mit OR-Logik verbundene Operatoren angewendet

Zum Beispiel:

- apple OR iphone ipad würde als apple OR (iphone ipad) ausgewertet
- ipad iphone OR android würde als (iphone ipad) OR android ausgewertet

Um Unsicherheiten zu vermeiden und sicherzustellen, dass Ihre Abfrage wie beabsichtigt ausgewertet wird, gruppieren Sie Begriffe bei Bedarf mit Klammern. 

Zum Beispiel:

- (apple OR iphone) ipad
- iphone (ipad OR android)
   

**Interpunktion, Diakritika und Groß-/Kleinschreibung**

Wenn Sie eine Schlüsselwort- oder Hashtag-Abfrage mit Akzenten oder Diakritika angeben, stimmt sie mit Post-Text überein, der sowohl den Begriff mit Akzenten und Diakritika als auch den entsprechenden Begriff mit normalen Zeichen enthält. Zum Beispiel stimmen Abfragen mit dem Schlüsselwort Diacrítica oder dem Hashtag #cumpleaños mit _Diacrítica_ oder _#cumpleaños_ überein, ebenso wie mit _Diacritica_ oder _#cumpleanos_ ohne Tilde í oder eñe.

Zeichen mit Akzenten oder Diakritika werden wie normale Zeichen behandelt und nicht als Wortgrenzen. Eine Abfrage mit dem Schlüsselwort cumpleaños würde also nur Aktivitäten finden, die das Wort _cumpleaños_ enthalten, und nicht solche, die _cumplea_, _cumplean_ oder _os_ enthalten.

Alle Operatoren werden ohne Beachtung der Groß-/Kleinschreibung ausgewertet. Die Abfrage cat stimmt zum Beispiel mit Posts überein, die eines der Folgenden enthalten: _cat_, _CAT_, _Cat_.

Das Abgleichsverhalten des [Gefilterten Streams](/de/x-api/posts/filtered-stream) unterscheidet sich von dem der Post-Zählungen. Beim [Erstellen einer Regel für den Gefilterten Stream](/de/x-api/posts/filtered-stream#building-rules-for-filtered-stream) beachten Sie, dass Schlüsselwörter und Hashtags mit Akzenten und Diakritika nur mit Begriffen übereinstimmen, die ebenfalls den Akzent bzw. das Diakritikum enthalten, und nicht mit Begriffen, die stattdessen normale Zeichen verwenden. 

Beispielsweise stimmen Regeln für den Gefilterten Stream, die das Schlüsselwort Diacrítica oder den Hashtag #cumpleaños enthalten, nur mit den Begriffen _Diacrítica_ und _#cumpleaños_ überein und nicht mit _Diacritica_ oder _#cumpleanos_ ohne Tilde í oder eñe.

**Spezifität und Effizienz**

Wenn Sie mit dem Erstellen Ihrer Abfrage beginnen, sollten Sie einige Punkte beachten.

- Die Verwendung breiter, eigenständiger Operatoren für Ihre Abfrage, etwa eines einzelnen Keywords oder #Hashtags, wird im Allgemeinen nicht empfohlen, da sie voraussichtlich auf ein enormes Volumen an Posts matchen. Eine robustere Abfrage führt zu einer spezifischeren Menge übereinstimmender Posts und erhöht idealerweise die Genauigkeit Ihrer Post-Zählungen, sodass Sie wertvollere Erkenntnisse gewinnen.
  - Wenn Ihre Abfrage zum Beispiel nur das Keyword happy ist, erhalten Sie voraussichtlich zwischen 200.000 und 300.000 Posts pro Tag.
  - Das Hinzufügen weiterer Bedingungsoperatoren verengt Ihre Ergebnisse, zum Beispiel (happy OR happiness) place\_country:GB -birthday -is:retweet
- Effiziente Abfragen helfen auch dabei, innerhalb der Beschränkung der Abfragelänge zu bleiben. Die Zeichenzahl umfasst die gesamte Abfragezeichenfolge einschließlich Leerzeichen und Operatoren.
  - Zum Beispiel ist die folgende Abfrage 59 Zeichen lang: (happy OR happiness) place\_country:GB -birthday -is:retweet

**Matching-Verhalten bei Quote Tweets**

Bei der Verwendung der Post-Count-Endpunkte matchen Operatoren nicht auf den Inhalt des ursprünglich zitierten Posts, sondern nur auf den im Quote Tweet enthaltenen Inhalt.

Bitte beachten Sie jedoch, dass der [Gefilterte Stream](/de/x-api/posts/filtered-stream) sowohl auf den Inhalt des ursprünglich zitierten Posts als auch auf den Inhalt des Quote Tweets matcht.
 

**Iteratives Erstellen einer Abfrage**

**Testen Sie Ihre Abfrage früh und häufig**

Es ist selten, dass eine Abfrage beim ersten Versuch die „richtigen“ Ergebnisse liefert. Auf X gibt es sehr viel, was anfangs möglicherweise nicht offensichtlich ist, und die oben beschriebene Abfragesyntax lässt sich unter Umständen nur schwer auf Ihre gewünschte Abfrage abbilden.

Während Sie eine Abfrage entwickeln, ist es wichtig, sie regelmäßig mithilfe eines der [Search Post](/de/x-api/posts/search/introduction)-Endpunkte zu testen, um sicherzustellen, dass die Posts, die auf Ihre Abfrage matchen, für Ihren Anwendungsfall relevant sind.

Für diesen Abschnitt beginnen wir mit der folgenden Abfrage und passen sie basierend auf den Ergebnissen an, die wir während unserer Tests erhalten: 

happy OR happiness

**Ergebnisse nutzen, um die Abfrage einzugrenzen**

Wenn Sie die Abfrage mit Search Posts testen, sollten Sie die zurückgegebenen Posts prüfen, um festzustellen, ob sie die Daten enthalten, die Sie erwarten. Mit einer breiten Abfrage und einer Obermenge an Post-Matches zu starten, ermöglicht es Ihnen, die Ergebnisse zu sichten und die Abfrage einzugrenzen, um unerwünschte Treffer herauszufiltern.  

Als wir die Beispielabfrage getestet haben, stellten wir fest, dass wir Posts in einer Vielzahl verschiedener Sprachen erhielten. In diesem Fall möchten wir nur Posts auf Englisch erhalten, daher fügen wir den Operator lang: hinzu:

(happy OR happiness) lang:en

Der Test lieferte zahlreiche Posts mit Geburtstagsglückwünschen, daher fügen wir -birthday als negierten Keyword-Operator hinzu. Wir möchten außerdem nur originale Posts erhalten, daher haben wir den negierten Operator -is:retweet ergänzt:

(happy OR happiness) lang:en -birthday -is:retweet

**Bei Bedarf für Inklusion anpassen**

Wenn Sie feststellen, dass Sie über Search Posts nicht die erwarteten Daten erhalten, obwohl es Posts gibt, die zurückgegeben werden sollten, müssen Sie Ihre Abfrage möglicherweise verbreitern, indem Sie Operatoren entfernen, die die gewünschten Daten herausfiltern.

In unserem Beispiel stellten wir fest, dass es in unserer persönlichen Timeline weitere Posts gab, die die gesuchte Emotion ausdrückten, aber nicht in den Testergebnissen enthalten waren. Um eine größere Abdeckung sicherzustellen, fügen wir die Keywords excited und elated hinzu.

(happy OR happiness OR excited OR elated) lang:en -birthday -is:retweet

**Für beliebte Trends/Spitzen im Zeitverlauf anpassen**

Trends kommen und gehen auf X schnell. Die Pflege Ihrer Abfrage sollte ein aktiver Prozess sein. Wenn Sie planen, eine Abfrage länger zu verwenden, empfehlen wir, die eingehenden Daten regelmäßig zu prüfen, um festzustellen, ob Anpassungen erforderlich sind.

In unserem Beispiel stellen wir fest, dass wir begonnen haben, einige Posts zu erhalten, die Menschen „happy holidays“ wünschen. Da wir diese Posts nicht in unsere Ergebnisse aufnehmen möchten, fügen wir das negierte Keyword -holidays hinzu.

(happy OR happiness OR excited OR elated) lang:en -birthday -is:retweet -holidays 

Sobald Sie Ihre Abfrage ordnungsgemäß getestet und iteriert haben, können Sie beginnen, sie mit den Post-Count-Endpunkten zu verwenden, um nur das Volumen der Posts zu erhalten, statt der vollständigen Post-Payloads.

<div id="adding-a-query-to-your-request">
  #### Eine Abfrage zu Ihrer Anfrage hinzufügen
</div>

Um eine Abfrage zu Ihrer Anfrage hinzuzufügen, müssen Sie den Parameter query verwenden. Wie bei allen Query-Parametern müssen Sie sicherstellen, dass die von Ihnen erstellte Abfrage HTTP-codiert ist.

Hier ist ein Beispiel, wie das mit einem cURL-Befehl aussehen kann. Wenn Sie diesen Befehl verwenden möchten, ersetzen Sie bitte $BEARER\_TOKEN durch Ihr eigenes [Bearer-Token](/de/resources/fundamentals/authentication#oauth-2-0):

```
      curl https://api.x.com/2/tweets/counts/recent?query=cat%20has%3Amedia%20-grumpy&tweet.fields=created_at&max_results=100 -H "Authorization: Bearer $BEARER_TOKEN"
```

<div id="query-examples">
  #### Abfragebeispiele
</div>

**Nachverfolgung einer Naturkatastrophe**

Die folgende Abfrage erfasst originale Posts von Wetterbehörden und Messstellen, die Hurrikan Harvey betreffen, der 2017 Houston traf.

So würde die Abfrage ohne HTTP-Encoding aussehen:

has:geo (from:NWSNHC OR from:NHC\_Atlantic OR from:NWSHouston OR from:NWSSanAntonio OR from:USGS\_TexasRain OR from:USGS\_TexasFlood OR from:JeffLindner1) -is:retweet

Und so würde die Abfrage mit dem HTTP-Encoding, dem query-Parameter und der URI für aktuelle Post-Zählungen aussehen:

https://api.x.com/2/tweets/counts/recent?query=-is%3Aretweet%20has%3Ageo%20(from%3ANWSNHC%20OR%20from%3ANHC\_Atlantic%20OR%20from%3ANWSHouston%20OR%20from%3ANWSSanAntonio%20OR%20from%3AUSGS\_TexasRain%20OR%20from%3AUSGS\_TexasFlood%20OR%20from%3AJeffLindner1)

**Bewertung der Stimmung einer Unterhaltung**

Die nächste Regel kann verwendet werden, um die Stimmung der sich um den Hashtag _#nowplaying_ entwickelnden Unterhaltung besser zu verstehen, jedoch nur für Posts, die innerhalb Nordamerikas veröffentlicht wurden.

So würden die beiden unterschiedlichen Abfragen, eine für positiv und eine für negativ, ohne HTTP-Encoding aussehen:

\#nowplaying (happy OR exciting OR excited OR favorite OR fav OR amazing OR lovely OR incredible) (place\_country:US OR place\_country:MX OR place\_country:CA) -horrible -worst -sucks -bad -disappointing

\#nowplaying (horrible OR worst OR sucks OR bad OR disappointing) (place\_country:US OR place\_country:MX OR place\_country:CA) -happy -exciting -excited -favorite -fav -amazing -lovely -incredible

Und so würden die Abfragen mit dem HTTP-Encoding, dem query-Parameter und der URI für aktuelle Post-Zählungen aussehen:

https://api.x.com/2/tweets/counts/recent?query=%23nowplaying%20(happy%20OR%20exciting%20OR%20excited%20OR%20favorite%20OR%20fav%20OR%20amazing%20OR%20lovely%20OR%20incredible)%20(place\_country%3AUS%20OR%20place\_country%3AMX%20OR%20place\_country%3ACA)%20-horrible%20-worst%20-sucks%20-bad%20-disappointing

https://api.x.com/2/tweets/counts/recent?query=%23nowplaying%20(horrible%20OR%20worst%20OR%20sucks%20OR%20bad%20OR%20disappointing)%20(place\_country%3AUS%20OR%20place\_country%3AMX%20OR%20place\_country%3ACA)%20-happy%20-exciting%20-excited%20-favorite%20-fav%20-amazing%20-lovely%20-incredible

**Posts finden, die sich auf eine bestimmte Post-Annotation beziehen**

Diese Regel wurde erstellt, um originale Posts zu filtern, die ein Bild eines Haustiers enthalten, das keine Katze ist, wobei die im Post erkannte Sprache Japanisch ist. Dazu verwendeten wir den Operator context:, um die Funktionalität der [Post-Annotation](/de/x-api/fundamentals/post-annotations) zu nutzen. Zuerst verwendeten wir den Endpoint [Post Lookup](/de/x-api/posts/lookup/introduction) und den Fields-Parameter tweet.fields=context\_annotations, um zu ermitteln, welche domain.entity-IDs wir in unserer Abfrage verwenden müssen:

- Posts, die sich auf Katzen beziehen, geben **domain** 66 (Kategorie Interessen und Hobbys) mit entity 852262932607926273 (Cats) zurück.
- Posts, die sich auf Haustiere beziehen, geben **domain** 65 (Interessen und Hobbys, Vertikal) mit entity 852262932607926273 (Pets) zurück.

So würde die Abfrage ohne HTTP-Encoding aussehen:

context:65.852262932607926273 -context:66.852262932607926273 -is:retweet has:images lang:ja

Und so würde die Abfrage mit dem HTTP-Encoding, dem query-Parameter und der URI für aktuelle Post-Zählungen aussehen:

https://api.x.com/2/tweets/counts/recent?query=context%3A65.852262932607926273%20-context%3A66.852262932607926273%20-is%3Aretweet%20has%3Aimages%20lang%3Aja

<div id="operators">
  #### Operatoren
</div>

| Operator                | Type         | Availability | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
|:------------------------|:--------------|:--------------|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `keyword`              | Standalone   | Core         | Findet ein Schlüsselwort im Text eines Posts. Dies ist ein tokenisierter Abgleich, d. h. Ihre Schlüsselwort-Zeichenfolge wird mit dem tokenisierten Text des Posts abgeglichen. Die Tokenisierung trennt Wörter anhand von Satzzeichen, Symbolen und Trennzeichen der Unicode-Basis-Ebene. Ein Post mit dem Text „I like coca-cola“ würde beispielsweise in folgende Token aufgeteilt: I, like, coca, cola. Diese Token werden dann mit der in Ihrer Abfrage verwendeten Schlüsselwort-Zeichenfolge verglichen. Um Zeichenfolgen mit Satzzeichen (z. B. coca-cola), Symbolen oder Trennzeichen abzugleichen, müssen Sie Ihr Schlüsselwort in doppelte Anführungszeichen setzen. Beispiel: `pepsi OR cola OR "coca cola"` |
| `emoji`                | Standalone   | Core         | Findet ein Emoji im Text eines Posts. Ähnlich wie bei einem Schlüsselwort handelt es sich um einen tokenisierten Abgleich, d. h. Ihr Emoji wird mit dem tokenisierten Text des Posts abgeglichen. Beachten Sie, dass Sie ein Emoji mit Variante in doppelte Anführungszeichen setzen müssen, um es zu einer Abfrage hinzuzufügen. Beispiel: `(😃 OR 😡) 😬`                                                                                                                                                                                                                     |
| `"exact phrase match"` | Standalone   | Core         | Findet die exakte Wortgruppe im Text eines Posts. Beispiel: `("X API" OR #v2) -"recent counts"`                                                                                                                                                                                                                                                                                                                                                                                                                  |
| `#`                    | Standalone   | Core         | Findet jeden Post, der einen erkannten Hashtag enthält, sofern der Hashtag als erkannte Entität im Post vorliegt. Dieser Operator führt einen exakten Abgleich durch, KEINEN tokenisierten Abgleich. Das bedeutet, die Regel `#thanku` stimmt mit Posts mit dem exakten Hashtag #thanku überein, jedoch nicht mit solchen mit dem Hashtag #thankunext. Beispiel: `#thankunext #fanart OR @arianagrande`                                                                                                                                                                         |
| `@`                    | Standalone   | Core         | Findet jeden Post, der den angegebenen Benutzernamen erwähnt, sofern der Benutzername eine erkannte Entität ist (einschließlich des @-Zeichens). Beispiel: `(@XDevelopers OR @API) -@X`                                                                                                                                                                                                                                                                                                                                                     |
| `$`                    | Standalone   | Advanced      | Findet jeden Post, der das angegebene „Cashtag“ enthält (bei dem das erste Zeichen des Tokens das „$“-Zeichen ist). Beachten Sie, dass der Cashtag-Operator zur Erkennung von Cashtags auf die „symbols“-Entitätsextraktion von X zurückgreift, statt zu versuchen, das Cashtag direkt aus dem Text zu extrahieren. Beispiel: `$twtr OR @XDevelopers -$fb`                                                                                                                                                                         |
| `from:`                | Standalone   | Core         | Findet jeden Post eines bestimmten Nutzers. Der Wert kann entweder der Benutzername (ohne das @-Zeichen) oder die numerische Benutzer-ID sein. Pro `from:`-Operator kann nur ein einzelner Benutzername bzw. eine einzelne ID übergeben werden. Beispiel: `from:XDevelopers OR from:API -from:X`                                                                                                                                                                                                                                                     |
| `to:`                  | Standalone   | Core         | Findet jeden Post, der als Antwort an einen bestimmten Nutzer gerichtet ist. Der Wert kann entweder der Benutzername (ohne das @-Zeichen) oder die numerische Benutzer-ID sein. Pro `to:`-Operator kann nur ein einzelner Benutzername bzw. eine einzelne ID übergeben werden. Beispiel: `to:XDevelopers OR to:API -to:X`                                                                                                                                                                                                                                                  |
| `url:`                 | Standalone   | Core         | Führt einen tokenisierten Abgleich für jede gültig formatierte URL eines Posts durch. Dieser Operator kann sowohl auf den Inhalt der Felder `url` als auch `expanded_url` matchen. Ein Post, der beispielsweise „You should check out X Developer Labs: https://t.co/c0A36SWil4“ enthält (wobei die Kurz-URL auf https://developer.x.com weiterleitet), erfüllt beide folgenden Regeln: `from:XDevelopers url:"https://developer.x.com"` und `from:XDevelopers url:"https://t.co"`. Tokens und Wortgruppen mit Satzzeichen oder Sonderzeichen sollten in doppelte Anführungszeichen gesetzt werden. |
| `retweets_of:`         | Standalone   | Core         | Findet Posts, die Retweets des angegebenen Nutzers sind. Der Wert kann entweder der Benutzername (ohne das @-Zeichen) oder die numerische Benutzer-ID sein. Pro `retweets_of:`-Operator kann nur ein einzelner Benutzername bzw. eine einzelne ID übergeben werden. Beispiel: `retweets_of:XDevelopers OR retweets_of:API`                                                                                                                                                                                                                                     |
| `context:`             | Standalone   | Core         | Findet Posts mit einem bestimmten Domain-ID/Entity-ID-Paar. Pro `context:`-Operator kann nur eine einzelne Domain/Entity übergeben werden. Beispiel: `context:domain_id.entity_id`. Mehrere Domains/Entities können mit dem ODER-Operator kombiniert werden: `(context:47.113922 9372198469633 OR context:11.1088514520308342784)`                                                                                                                                           |
| `entity:`              | Standalone   | Core         | Findet Posts mit einem bestimmten Entity-Zeichenfolgenwert. Es kann nur ein einzelner `entity:`-Operator verwendet werden. Beispiel: `entity:"string declaration of entity/place"`. Bitte beachten Sie, dass dies nur mit der jüngsten Suche verfügbar ist.                                                                                                                                                                                                                                  |
| `conversation_id:`     | Standalone   | Core         | Findet Posts, die eine gemeinsame Konversations-ID haben. Eine Konversations-ID entspricht der Post-ID des Posts, der eine Konversation gestartet hat. Wenn Antworten auf einen Post veröffentlicht werden – auch Antworten auf Antworten –, wird die `conversation_id` in dessen JSON-Payload hinzugefügt. Pro `conversation_id:`-Operator kann nur eine einzelne Konversations-ID übergeben werden. Beispiel: `conversation_id:1334987486343299072 (from:XDevelopers OR from:API)` |
| `list:`                | Standalone   | Advanced      | Findet Posts, die von Nutzern veröffentlicht wurden, die Mitglieder einer angegebenen Liste sind. Wenn beispielsweise @XDevelopers und @API Mitglieder der Liste 123 wären und Sie `list:123` in Ihre Abfrage aufnehmen, enthält Ihre Antwort nur Posts, die von diesen Accounts veröffentlicht wurden. Listen-IDs können über den List-Lookup-Endpoint ermittelt werden. Beispiel: `list:123`                                                                                                                                        |
| `place:`               | Standalone   | Advanced      | Findet Posts, die mit dem angegebenen Ort oder der X-Place-ID getaggt sind. Mehrwort-Ortsnamen („New York City“, „Palo Alto“) sollten in Anführungszeichen stehen. Pro `place:`-Operator kann nur ein einzelner Ort verwendet werden. Hinweis: Siehe den Standard-Endpoint GET geo/search v1.1, um X-Place-IDs zu erhalten. Beispiel: `place:"new york city" OR place:seattle OR place:fd70c22040963ac7`                                                                                       |
| `place_country:`       | Standalone   | Advanced      | Findet Posts, bei denen der Ländercode des getaggten Orts/der getaggten Location dem angegebenen ISO-Alpha-2-Code entspricht. Eine Liste gültiger ISO-Codes finden Sie auf Wikipedia. Pro `place_country:`-Operator kann nur ein einzelner ISO-Code verwendet werden. Beispiel: `place_country:US OR place_country:MX OR place_country:CA`                                                                                                  |
| `point_radius:`        | Standalone   | Advanced      | Vergleicht mit dem Objekt `place.geo.coordinates` des Posts, wenn vorhanden, und in X mit einem Place-Geo-Polygon, wobei das Place-Polygon vollständig innerhalb der definierten Region liegt. `point_radius:[longitude latitude radius]`. Unterstützte Einheiten für den Radius sind Meilen (mi) und Kilometer (km). Der Radius muss kleiner als 25 mi sein. Der Längengrad liegt im Bereich von ±180. Der Breitengrad liegt im Bereich von ±90. Alle Koordinaten sind in Dezimalgrad. Regelargumente stehen in Klammern und sind durch Leerzeichen getrennt. Beispiel: `point_radius:[2.355128 48.861118 16km] OR point_radius:[-41.287336 174.761070 20mi]` |
| `bounding_box:`        | Standalone   | Advanced      | Vergleicht mit dem Objekt place.geo.coordinates des Posts, wenn vorhanden, und in X mit einem Place-Geo-Polygon, wobei das Place-Polygon vollständig innerhalb der definierten Region liegt. `bounding_box:[west_long south_lat east_long north_lat]`. Breite und Höhe der Bounding-Box müssen kleiner als 25 mi sein. Der Längengrad liegt im Bereich von ±180. Der Breitengrad liegt im Bereich von ±90. Alle Koordinaten sind in Dezimalgrad. Regelargumente stehen in Klammern und sind durch Leerzeichen getrennt. Beispiel: `bounding_box:[-105.301758 39.964069 -105.178505 40.09455]` |
| `is:retweet`           | Conjunction required | Core         | Findet Retweets, die dem Rest der angegebenen Regel entsprechen. Dieser Operator sucht nur nach echten Retweets (z. B. solchen, die mit der Retweet-Schaltfläche erzeugt wurden). Zitierte Posts werden von diesem Operator nicht erfasst. Beispiel: `data @XDevelopers -is:retweet`                                                                                                                                                                                                                                  |
| `is:reply`             | Conjunction required | Core         | Liefert nur explizite Antworten, die einer Regel entsprechen. Kann auch negiert werden, um Antworten, die einer Abfrage entsprechen, von der Zustellung auszuschließen. Hinweis: Dieser Operator ist auch mit dem Endpoint Gefilterter Stream verfügbar. Bei Verwendung mit Gefilterter Stream findet dieser Operator Antworten auf einen ursprünglichen Post, Antworten in zitierten Posts und Antworten in Retweets. Beispiel: `from:XDevelopers is:reply`                                                                                                  |
| `is:quote`             | Konjunktion erforderlich | Core         | Gibt alle Quote-Tweets zurück, auch bekannt als Posts mit Kommentar. Beispiel: `"sentiment analysis" is:quote`                                                                                                                                                                                                                                                                                                                                                       |
| `is:verified`          | Konjunktion erforderlich | Core         | Liefert nur Posts, deren Autorinnen oder Autoren von X verifiziert sind. Beispiel: `#nowplaying is:verified`                                                                                                                                                                                                                                                                                                                                                                  |
| `-is:nullcast`         | Konjunktion erforderlich | Advanced      | Entfernt Posts, die ausschließlich zur Bewerbung auf ads.x.com erstellt wurden und `"source":"Twitter for Advertisers (legacy)"` oder `"source":"Twitter for Advertisers"` enthalten. Dieser Operator muss negiert werden. Weitere Informationen zu nullgecasteten Posts finden Sie auf unserer Seite zur Post-Verfügbarkeit. Beispiel: `"mobile games" -is:nullcast`                                                                                                                                        |
| `has:hashtags`         | Konjunktion erforderlich | Core         | Findet Posts, die mindestens einen Hashtag enthalten. Beispiel: `from:XDevelopers -has:hashtags`                                                                                                                                                                                                                                                                                                                                                                  |
| `has:cashtags`         | Konjunktion erforderlich | Advanced      | Findet Posts, die ein Cashtag-Symbol enthalten (mit vorangestelltem „$“-Zeichen; zum Beispiel `$tag`). Beispiel: `#stonks has:cashtags`                                                                                                                                                                                                                                                                                                                                                       |
| `has:links`            | Konjunktion erforderlich | Core         | Dieser Operator findet Posts, die Links und Medien im Post-Text enthalten. Beispiel: `from:XDevelopers announcement has:links`                                                                                                                                                                                                                                                                                                                                                       |
| `has:mentions`         | Konjunktion erforderlich | Core         | Findet Posts, die eine andere X Nutzerin oder einen anderen X Nutzer erwähnen. Beispiel: `#nowplaying has:mentions`                                                                                                                                                                                                                                                                                                                                                                  |
| `has:media`            | Konjunktion erforderlich | Core         | Findet Posts, die ein Medienobjekt enthalten, z. B. ein Foto, GIF oder Video, wie von X bestimmt. Dies trifft nicht auf Medien zu, die mit Periscope erstellt wurden, oder auf Posts mit Links zu anderen Medien-Hosting-Seiten. Beispiel: `(kittens OR puppies) has:media`                                                                                                                                                                                                                                  |
| `has:images`           | Konjunktion erforderlich | Core         | Findet Posts, die eine erkannte URL zu einem Bild enthalten. Beispiel: `#meme has:images`                                                                                                                                                                                                                                                                                                                                                                  |
| `has:videos`           | Konjunktion erforderlich | Core         | Findet Posts, die native X Videos enthalten, die direkt auf X hochgeladen wurden. Dies trifft nicht auf Videos zu, die mit Periscope erstellt wurden, oder auf Posts mit Links zu anderen Video-Hosting-Seiten. Beispiel: `#icebucketchallenge has:videos`                                                                                                                                                                                                                                  |
| `has:geo`              | Konjunktion erforderlich | Advanced      | Findet Posts mit postspezifischen Geodaten, die von der X Nutzerin oder dem X Nutzer bereitgestellt wurden. Dies kann entweder ein Ort in Form eines X Place mit entsprechendem Anzeigenamen, Geo-Polygon und anderen Feldern sein oder in seltenen Fällen eine Geo-Längen-/Breitenkoordinate. Hinweis: Operatoren, die auf Place (Post-Geo) matchen, umfassen nur Treffer aus Original-Posts. Retweets enthalten keine Place-Daten. Beispiel: `recommend #paris has:geo -bakery` |
| `lang:`                | Konjunktion erforderlich | Core         | Findet Posts, die von X als in einer bestimmten Sprache verfasst klassifiziert wurden (nur, wenn der Post klassifiziert wurde). Wichtig: Jeder Post ist derzeit nur als eine Sprache klassifiziert; das UND-Verknüpfen mehrerer Sprachen liefert daher keine Ergebnisse. Pro `lang:`-Operator kann nur ein BCP‑47‑Sprachkennzeichen übergeben werden. Hinweis: Wenn keine Sprachklassifizierung möglich ist, lautet das Ergebnis „und“ (für undefined). Beispiel: `recommend #paris lang:en` |

|     |     |     |     |
| :--- | :--- | :--- | :--- |
| Amharisch: **am** | Deutsch: **de** | Malayalam: **ml** | Slowakisch: **sk** |
| Arabisch: **ar** | Griechisch: **el** | Dhivehi (Maledivisch): **dv** | Slowenisch: **sl** |
| Armenisch: **hy** | Gujarati: **gu** | Marathi: **mr** | Sorani-Kurdisch: **ckb** |
| Baskisch: **eu** | Haitianisches Kreolisch: **ht** | Nepali: **ne** | Spanisch: **es** |
| Bengalisch: **bn** | Hebräisch: **iw** | Norwegisch: **no** | Schwedisch: **sv** |
| Bosnisch: **bs** | Hindi: **hi** | Odia (Oriya): **or** | Tagalog: **tl** |
| Bulgarisch: **bg** | Lateinschriftliches Hindi: **hi-Latn** | Panjabi: **pa** | Tamil: **ta** |
| Birmanisch (Myanmar): **my** | Ungarisch: **hu** | Paschtu: **ps** | Telugu: **te** |
| Kroatisch: **hr** | Isländisch: **is** | Persisch: **fa** | Thailändisch: **th** |
| Katalanisch: **ca** | Indonesisch: **in** | Polnisch: **pl** | Tibetisch: **bo** |
| Tschechisch: **cs** | Italienisch: **it** | Portugiesisch: **pt** | Traditionelles Chinesisch: **zh-TW** |
| Dänisch: **da** | Japanisch: **ja** | Rumänisch: **ro** | Türkisch: **tr** |
| Niederländisch: **nl** | Kannada: **kn** | Russisch: **ru** | Ukrainisch: **uk** |
| Englisch: **en** | Khmer: **km** | Serbisch: **sr** | Urdu: **ur** |
| Estnisch: **et** | Koreanisch: **ko** | Vereinfachtes Chinesisch: **zh-CN** | Uigurisch: **ug** |
| Finnisch: **fi** | Lao: **lo** | Sindhi: **sd** | Vietnamesisch: **vi** |
| Französisch: **fr** | Lettisch: **lv** | Singhalesisch: **si** | Walisisch: **cy** |
| Georgisch: **ka** | Litauisch: **lt** |     |