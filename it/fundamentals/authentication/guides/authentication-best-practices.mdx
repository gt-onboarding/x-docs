---
title: Buone pratiche
---

import { Button } from "/snippets/it/button.mdx";

Le chiavi e i token API vanno protetti con la massima cura.¬†

Queste credenziali sono direttamente associate alla tua [App per sviluppatori](/it/resources/fundamentals/developer-apps) e agli account X che ti hanno autorizzato a inviare richieste per loro conto. Se le tue chiavi vengono compromesse, soggetti malintenzionati potrebbero usarle per inviare richieste agli endpoint di X per conto della tua App per sviluppatori o dei relativi utenti autorizzati, con il rischio di raggiungere limiti di frequenza imprevisti, consumare il tuo contingente di accesso a pagamento o persino causare la sospensione della tua App per sviluppatori.

Le sezioni seguenti includono le best practice da considerare quando gestisci chiavi e token API.

<div id="regenerate-api-keys-and-tokens">
  ## Rigenerare le chiavi e i token dell'API
</div>

Se ritieni che le tue chiavi API siano state esposte, rigenerale seguendo questi passaggi:

1. Vai alla [pagina ‚ÄúProgetti e App‚Äù del portale per sviluppatori](https://developer.x.com/en/portal/projects-and-apps.html).
2. Fai clic sull‚Äôicona ‚ÄúKeys and tokens‚Äù (üóù) accanto all‚ÄôApp pertinente.
3. Fai clic sul pulsante ‚ÄúRegenerate‚Äù accanto al set di chiavi e token che desideri rigenerare.

Se preferisci rigenerare in modo programmatico i tuoi Access Token o Bearer Token, puoi farlo utilizzando i nostri endpoint di autenticazione.

- Se desideri rigenerare gli Access Token, devi prima invalidare i token utilizzando l‚Äôendpoint [POST oauth/invalidate\_token](/it/resources/fundamentals/authentication/api-reference#post-oauth2-invalidate-token), quindi rigenerarli utilizzando il [flusso OAuth a 3 passaggi](/it/resources/fundamentals/authentication/oauth-1-0a/obtaining-user-access-tokens).
- Se desideri rigenerare il Bearer Token, devi prima invalidare il token utilizzando l‚Äôendpoint [POST oauth2/invalidate\_token](/it/resources/fundamentals/authentication/api-reference#post-oauth2-invalidate-token), quindi rigenerarlo utilizzando l‚Äôendpoint [POST oauth2/token](/it/resources/fundamentals/authentication/api-reference#post-oauth2-token).

<div id="having-a-central-file-for-your-secrets">
  ## Avere un file centrale per i segreti
</div>

Disporre di un file, ad esempio un file .env o un file .yaml, per conservare i segreti pu√≤ essere utile; assicurati per√≤ di avere un .gitignore robusto che impedisca di aggiungerli per errore a un repository Git.¬†

<div id="environment-variables">
  ## Variabili d'ambiente
</div>

Pu√≤ essere utile scrivere codice che utilizzi variabili d'ambiente.

Ecco un esempio in Python:

```python
import os

consumer_key = os.environ.get("CONSUMER_KEY")

consumer_secret = os.environ.get("CONSUMER_SECRET")
```

Nel terminale, esegui comandi come i seguenti:

```bash
export CONSUMER_KEY='xxxxxxxxxxxxxxxxxxx'
export CONSUMER_SECRET='xxxxxxxxxxxxxxxxxxxxxxx'
```

<div id="source-code-and-version-control">
  ## Codice sorgente e controllo delle versioni
</div>

Gli errori di sicurezza pi√π comuni commessi dagli sviluppatori consistono nell‚Äôavere chiavi e token API inseriti nel codice sorgente in sistemi di controllo versione accessibili come GitHub e Bitbucket. Molti di questi repository di codice sono pubblicamente accessibili. Questo errore √® talmente frequente nei repository pubblici che esistono bot redditizi che eseguono scraping alla ricerca di chiavi API.

- Usa variabili d‚Äôambiente sul server. Archiviando le chiavi API nelle variabili d‚Äôambiente, le tieni fuori dal codice e dal controllo delle versioni. Questo consente anche di usare facilmente chiavi diverse per ambienti diversi.
- Usa un file di configurazione escluso dal controllo versione. Aggiungi il nome del file al tuo [.gitignore](https://git-scm.com/docs/gitignore) per escluderlo dal tracciamento da parte del controllo versione.
- Se rimuovi le chiavi API dal codice dopo aver usato il controllo versione, √® probabile che siano ancora recuperabili accedendo alle versioni precedenti della codebase. Rigenera le chiavi API, come descritto nella sezione successiva.

<div id="databases">
  ## Database
</div>

Se devi archiviare i token di accesso in un database, tieni presente quanto segue:

- Limita l‚Äôaccesso al database in modo che i token di accesso siano leggibili solo dal proprietario del token.
- Limita i privilegi di modifica/scrittura sulla tabella del database che contiene i token di accesso: questo dovrebbe essere automatizzato dal sistema di gestione delle chiavi.
- Cifra i token di accesso prima di archiviarli in qualsiasi archivio dati.

<div id="password-management-tools">
  ## Strumenti di gestione delle password
</div>

Strumenti di gestione delle password come 1Password o LastPass possono essere utili per conservare chiavi e token in un luogo sicuro. Potresti voler evitare di condividerli all‚Äôinterno di un gestore di password condiviso dal team.

<div id="web-storage-cookies">
  ## Web storage & cookies
</div>

Esistono due tipi di web storage: LocalStorage e SessionStorage. Sono stati introdotti come miglioramento rispetto all‚Äôuso dei cookie, poich√© la capacit√† di archiviazione del web storage √® molto pi√π elevata rispetto a quella dei cookie. Tuttavia, ciascuna di queste opzioni di archiviazione presenta diversi pro e contro.
¬†

**Web Storage: LocalStorage**

Qualsiasi elemento archiviato nel web storage locale √® persistente. Ci√≤ significa che i dati rimarranno finch√© non verranno esplicitamente eliminati. A seconda delle esigenze del tuo progetto, potresti considerarlo un aspetto positivo. Tuttavia, √® opportuno usare LocalStorage con attenzione, poich√© eventuali modifiche/aggiunte ai dati saranno disponibili in tutte le visite future alla pagina web in questione. In genere non consigliamo l‚Äôuso di LocalStorage, sebbene possano esserci alcune eccezioni. Se decidi di usare LocalStorage, √® utile sapere che supporta la same-origin policy, quindi tutti i dati archiviati qui saranno disponibili solo dalla stessa origine. Un ulteriore vantaggio prestazionale dell‚Äôuso di LocalStorage √® la riduzione del traffico client-server, poich√© i dati non devono essere inviati al server per ogni richiesta HTTP.
¬†

**Web Storage: SessionStorage**

SessionStorage √® simile a LocalStorage, ma la differenza fondamentale √® che non √® persistente. Una volta chiusa la finestra (o la scheda, a seconda del browser utilizzato) con cui si √® scritto su SessionStorage, i dati andranno persi. Questo √® utile per limitare l‚Äôaccesso in lettura al token all‚Äôinterno di una sessione utente. In termini di sicurezza, usare SessionStorage √® generalmente preferibile rispetto a LocalStorage. Come per LocalStorage, anche per SessionStorage valgono i vantaggi del supporto alla same-origin policy e della riduzione del traffico client-server.
¬†

**Cookies**

I cookie sono il metodo pi√π tradizionale per archiviare i dati di sessione. √à possibile impostare un tempo di scadenza per ciascun cookie, il che consente una revoca semplice e una restrizione dell‚Äôaccesso. Tuttavia, il traffico client-server aumenter√† sicuramente quando si usano i cookie, poich√© i dati vengono inviati al server per ogni richiesta HTTP. Se decidi di usare i cookie, devi proteggerti dal dirottamento di sessione. Per impostazione predefinita, i cookie vengono inviati in chiaro su HTTP, il che rende il loro contenuto vulnerabile al packet sniffing e/o ad attacchi man-in-the-middle in cui gli aggressori possono modificare il traffico. Dovresti sempre imporre l‚Äôuso di HTTPS per proteggere i dati in transito. Questo garantisce riservatezza, integrit√† (dei dati) e autenticazione. Tuttavia, se la tua applicazione o il tuo sito web sono disponibili sia tramite HTTP che HTTPS, dovresti anche usare il flag "Secure" sul cookie. Questo impedir√† agli aggressori di inviare a un utente link alla versione HTTP del tuo sito e di intercettare la richiesta HTTP risultante.

Un‚Äôulteriore difesa secondaria contro il dirottamento di sessione quando si usano i cookie consiste nel validare nuovamente l‚Äôidentit√† dell‚Äôutente prima di eseguire qualsiasi azione ad alto impatto. Un altro flag da considerare per migliorare la sicurezza dei cookie √® "HttpOnly". Questo flag indica al browser che il cookie in questione deve essere accessibile solo dal server specificato. Qualsiasi tentativo effettuato da script lato client sarebbe impedito da questo flag, contribuendo quindi a proteggere dalla maggior parte degli attacchi di cross-site scripting (XSS).