---
title: Gestión de desconexiones
sidebarTitle: Gestión de desconexiones
---

<div id="what-is-a-disconnection">
  ### ¿Qué es una desconexión?
</div>

Establecer una conexión con las API de streaming implica realizar una solicitud HTTPS de muy larga duración y analizar la respuesta de forma incremental. Al conectarte al endpoint del flujo filtrado, debes crear una solicitud HTTPS y consumir el flujo resultante durante todo el tiempo que sea práctico. Nuestros servidores mantendrán la conexión abierta indefinidamente, salvo que se produzca un error del lado del servidor, un retraso excesivo del lado del cliente, problemas de red, mantenimiento rutinario del servidor o inicios de sesión duplicados. Con las conexiones a endpoints de streaming, es probable —y debe preverse— que se produzcan desconexiones y que se implemente lógica de reconexión.
 

<div id="why-a-streaming-connection-might-be-disconnected">
  #### Por qué una conexión de streaming puede desconectarse
</div>

Tu stream puede desconectarse por varias razones. Revisa el mensaje de error que devuelve el stream para entender el motivo de la falla. Las posibles causas de desconexión son:

- Un error de autenticación (por ejemplo, un token incorrecto o un método de autenticación equivocado).
- Se reinicia un servidor de streaming del lado de X. Esto suele estar relacionado con un despliegue de código y, en general, debe anticiparse y contemplarse en el diseño.
- Tu cliente no mantiene el ritmo con el volumen de Publicaciones que entrega el stream o está leyendo los datos demasiado lentamente. Cada conexión de streaming está respaldada por una cola de mensajes que se enviarán al cliente. Si esta cola crece demasiado con el tiempo, la conexión se cerrará.
- Tu cuenta superó tu cuota diaria/mensual de Publicaciones.
- Tienes demasiadas conexiones redundantes activas.
- Un cliente deja de leer datos de forma repentina. Si la tasa de Publicaciones leídas del stream cae súbitamente, la conexión se cerrará.
- Posibles problemas de red entre el servidor y el cliente.
- Un problema temporal del lado del servidor, mantenimiento programado o actualizaciones. (Consulta la [página de estado](https://api.twitterstat.us/))
   

#### Los errores comunes de desconexión incluyen: 

```{
	"errors": [{
		"title": "operational-disconnect",
		"disconnect_type": "UpstreamOperationalDisconnect",
		"detail": "Este stream se ha desconectado en el origen por razones operativas.",
		"type": "https://api.x.com/2/problems/operational-disconnect"
	}]
}
```

```
{
	"title": "ConnectionException",
	"detail": "Este stream ha alcanzado el límite máximo de conexiones permitidas.",
	"connection_issue": "TooManyConnections",
	"type": "https://api.x.com/2/problems/streaming-connection"
}
```

<div id="anticipating-disconnects-and-reconnecting">
  #### Anticipar desconexiones y reconectar
</div>

Al transmitir publicaciones, el objetivo es permanecer conectado el mayor tiempo posible, reconociendo que pueden ocurrir desconexiones. El endpoint envía un latido de keep-alive cada 20 segundos (aparecerá como un carácter de nueva línea). Use esta señal para detectar si se está desconectando.

1. Su código debe detectar cuando dejan de llegar tanto contenido nuevo como el latido.
2. Si eso ocurre, su código debe activar la lógica de reconexión. Algunos clientes y lenguajes permiten especificar un tiempo de espera de lectura, que puede configurar en 20 segundos.
3. Su servicio debe detectar estas desconexiones y reconectarse lo antes posible.

Una vez que una conexión establecida se cae, intente reconectar inmediatamente. Si la reconexión falla, desacelere los intentos de reconexión según el tipo de error experimentado:

- Aplique backoff lineal para errores de red a nivel TCP/IP. Estos problemas suelen ser temporales y tienden a resolverse rápidamente. Aumente el retraso entre reconexiones en 250 ms en cada intento, hasta 16 segundos.
- Aplique backoff exponencial para errores HTTP en los que reconectar sea apropiado. Comience con una espera de 5 segundos, duplicando cada intento, hasta 320 segundos.
- Aplique backoff exponencial para errores HTTP 429 (Rate limit exceeded). Comience con una espera de 1 minuto y duplique cada intento. Tenga en cuenta que cada HTTP 429 recibido aumenta el tiempo que debe esperar hasta que el límite de frecuencia deje de estar vigente para su cuenta.
   

<div id="recovering-lost-data">
  #### Recuperación de datos perdidos
</div>

Si experimentas una desconexión, hay varias estrategias que puedes utilizar para asegurarte de recibir todos los datos que pudiste haber perdido. Hemos documentado pasos clave que puedes seguir para recuperar datos faltantes en nuestra guía de integración sobre [recuperación de datos](/es/x-api/posts/filtered-stream/integrate/recovery-and-redundancy-features). 
 

<div id="rate-limits-and-usage">
  #### Límites de uso y consumo
</div>

Para verificar los límites de conexión, la respuesta incluirá tres encabezados. Esto es útil para entender cuántas veces puede usar el endpoint de reglas y cuántos intentos de reconexión se permiten para el endpoint de streaming.

- x-rate-limit-limit indica la cantidad de solicitudes asignadas que su cliente puede realizar durante una ventana de 15 minutos.

- x-rate-limit-remaining indica la cantidad de solicitudes restantes en la ventana de 15 minutos.

- x-rate-limit-reset es una marca de tiempo UNIX que indica cuándo se reiniciará la ventana de 15 minutos, restableciendo x-rate-limit-remaining a 0.

El endpoint de Flujo filtrado actualmente no informa datos de uso. Para verificar cuántas Publicaciones se han entregado, su código puede implementar una lógica de medición, de modo que el consumo pueda medirse y pausarse si es necesario.

El código del lado del cliente del flujo simplemente inserta las Publicaciones entrantes en una cola FIFO (primero en entrar, primero en salir) o en una estructura de memoria similar; un proceso/hilo independiente debería consumir las Publicaciones de esa cola para analizarlas y preparar el contenido para su almacenamiento. Con este diseño, puede implementar un servicio que escale de manera eficiente en caso de que el volumen de Publicaciones entrantes cambie drásticamente. Conceptualmente, puede pensarlo como descargar un archivo infinitamente largo a través de HTTP.

<div id="reconnection-best-practices">
  #### Mejores prácticas de reconexión
</div>

**Prueba estrategias de backoff**

Una buena forma de probar una implementación de backoff es usar credenciales de autorización no válidas y examinar los intentos de reconexión. Una buena implementación no recibirá respuestas 429.

**Emite alertas por múltiples reconexiones**

Si un cliente alcanza su umbral superior del tiempo entre reconexiones, debería enviarte notificaciones para que puedas evaluar y resolver los problemas que afectan tu conexión.

**Gestiona cambios de DNS**

Prueba que tu proceso de cliente respete el Time To Live (TTL) de DNS. Algunas pilas almacenarán en caché una dirección resuelta durante toda la ejecución del proceso y no reconocerán cambios de DNS dentro del TTL prescrito. Un almacenamiento en caché tan agresivo provocará interrupciones del servicio en tu cliente a medida que X cambie la carga entre direcciones IP.

**User Agent**

Asegúrate de que tu encabezado HTTP user-agent incluya la versión del cliente. Esto será fundamental para diagnosticar problemas del lado de X. Si tu entorno impide configurar el campo user-agent, entonces establece un encabezado x-user-agent.